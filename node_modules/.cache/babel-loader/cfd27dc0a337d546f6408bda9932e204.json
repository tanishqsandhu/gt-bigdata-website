{"ast":null,"code":"import { filterDOMProps as $aywJT$filterDOMProps, mergeProps as $aywJT$mergeProps } from \"@react-aria/utils\";\nimport { useField as $aywJT$useField } from \"@react-aria/label\";\nimport { useFocusable as $aywJT$useFocusable } from \"@react-aria/focus\";\nimport { useRef as $aywJT$useRef, useEffect as $aywJT$useEffect } from \"react\";\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n\nvar $13fe50aacf882d03$exports = {};\n$parcel$export($13fe50aacf882d03$exports, \"useTextField\", () => $13fe50aacf882d03$export$712718f7aec83d5);\n\nfunction $13fe50aacf882d03$export$712718f7aec83d5(props, ref) {\n  let {\n    inputElementType = 'input',\n    isDisabled = false,\n    isRequired = false,\n    isReadOnly = false,\n    validationState: validationState,\n    type = 'text',\n    onChange = () => {}\n  } = props;\n  let {\n    focusableProps: focusableProps\n  } = $aywJT$useFocusable(props, ref);\n  let {\n    labelProps: labelProps,\n    fieldProps: fieldProps,\n    descriptionProps: descriptionProps,\n    errorMessageProps: errorMessageProps\n  } = $aywJT$useField(props);\n  let domProps = $aywJT$filterDOMProps(props, {\n    labelable: true\n  });\n  const inputOnlyProps = {\n    type: type,\n    pattern: props.pattern\n  };\n  return {\n    labelProps: labelProps,\n    inputProps: $aywJT$mergeProps(domProps, inputElementType === 'input' && inputOnlyProps, {\n      disabled: isDisabled,\n      readOnly: isReadOnly,\n      'aria-required': isRequired || undefined,\n      'aria-invalid': validationState === 'invalid' || undefined,\n      'aria-errormessage': props['aria-errormessage'],\n      'aria-activedescendant': props['aria-activedescendant'],\n      'aria-autocomplete': props['aria-autocomplete'],\n      'aria-haspopup': props['aria-haspopup'],\n      value: props.value,\n      defaultValue: props.value ? undefined : props.defaultValue,\n      onChange: e => onChange(e.target.value),\n      autoComplete: props.autoComplete,\n      maxLength: props.maxLength,\n      minLength: props.minLength,\n      name: props.name,\n      placeholder: props.placeholder,\n      inputMode: props.inputMode,\n      // Clipboard events\n      onCopy: props.onCopy,\n      onCut: props.onCut,\n      onPaste: props.onPaste,\n      // Composition events\n      onCompositionEnd: props.onCompositionEnd,\n      onCompositionStart: props.onCompositionStart,\n      onCompositionUpdate: props.onCompositionUpdate,\n      // Selection events\n      onSelect: props.onSelect,\n      // Input events\n      onBeforeInput: props.onBeforeInput,\n      onInput: props.onInput,\n      ...focusableProps,\n      ...fieldProps\n    }),\n    descriptionProps: descriptionProps,\n    errorMessageProps: errorMessageProps\n  };\n}\n\nvar $58c0262056d833d5$exports = {};\n$parcel$export($58c0262056d833d5$exports, \"useFormattedTextField\", () => $58c0262056d833d5$export$4f384c9210e583c3);\n\nfunction $58c0262056d833d5$var$supportsNativeBeforeInputEvent() {\n  return typeof window !== 'undefined' && window.InputEvent && // @ts-ignore\n  typeof InputEvent.prototype.getTargetRanges === 'function';\n}\n\nfunction $58c0262056d833d5$export$4f384c9210e583c3(props, state1, inputRef) {\n  let stateRef = $aywJT$useRef(state1);\n  stateRef.current = state1; // All browsers implement the 'beforeinput' event natively except Firefox\n  // (currently behind a flag as of Firefox 84). React's polyfill does not\n  // run in all cases that the native event fires, e.g. when deleting text.\n  // Use the native event if available so that we can prevent invalid deletions.\n  // We do not attempt to polyfill this in Firefox since it would be very complicated,\n  // the benefit of doing so is fairly minor, and it's going to be natively supported soon.\n\n  $aywJT$useEffect(() => {\n    if (!$58c0262056d833d5$var$supportsNativeBeforeInputEvent()) return;\n    let input = inputRef.current;\n\n    let onBeforeInput = e => {\n      let state = stateRef.current; // Compute the next value of the input if the event is allowed to proceed.\n      // See https://www.w3.org/TR/input-events-2/#interface-InputEvent-Attributes for a full list of input types.\n\n      let nextValue;\n\n      switch (e.inputType) {\n        case 'historyUndo':\n        case 'historyRedo':\n          // Explicitly allow undo/redo. e.data is null in this case, but there's no need to validate,\n          // because presumably the input would have already been validated previously.\n          return;\n\n        case 'deleteContent':\n        case 'deleteByCut':\n        case 'deleteByDrag':\n          nextValue = input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);\n          break;\n\n        case 'deleteContentForward':\n          // This is potentially incorrect, since the browser may actually delete more than a single UTF-16\n          // character. In reality, a full Unicode grapheme cluster consisting of multiple UTF-16 characters\n          // or code points may be deleted. However, in our currently supported locales, there are no such cases.\n          // If we support additional locales in the future, this may need to change.\n          nextValue = input.selectionEnd === input.selectionStart ? input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd + 1) : input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);\n          break;\n\n        case 'deleteContentBackward':\n          nextValue = input.selectionEnd === input.selectionStart ? input.value.slice(0, input.selectionStart - 1) + input.value.slice(input.selectionStart) : input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);\n          break;\n\n        case 'deleteSoftLineBackward':\n        case 'deleteHardLineBackward':\n          nextValue = input.value.slice(input.selectionStart);\n          break;\n\n        default:\n          if (e.data != null) nextValue = input.value.slice(0, input.selectionStart) + e.data + input.value.slice(input.selectionEnd);\n          break;\n      } // If we did not compute a value, or the new value is invalid, prevent the event\n      // so that the browser does not update the input text, move the selection, or add to\n      // the undo/redo stack.\n\n\n      if (nextValue == null || !state.validate(nextValue)) e.preventDefault();\n    };\n\n    input.addEventListener('beforeinput', onBeforeInput, false);\n    return () => {\n      input.removeEventListener('beforeinput', onBeforeInput, false);\n    };\n  }, [inputRef, stateRef]);\n  let onBeforeInput1 = !$58c0262056d833d5$var$supportsNativeBeforeInputEvent() ? e => {\n    let nextValue = e.target.value.slice(0, e.target.selectionStart) + e.data + e.target.value.slice(e.target.selectionEnd);\n    if (!state1.validate(nextValue)) e.preventDefault();\n  } : null;\n  let {\n    labelProps: labelProps,\n    inputProps: textFieldProps,\n    descriptionProps: descriptionProps,\n    errorMessageProps: errorMessageProps\n  } = $13fe50aacf882d03$export$712718f7aec83d5(props, inputRef);\n  let compositionStartState = $aywJT$useRef(null);\n  return {\n    inputProps: $aywJT$mergeProps(textFieldProps, {\n      onBeforeInput: onBeforeInput1,\n\n      onCompositionStart() {\n        // Chrome does not implement Input Events Level 2, which specifies the insertFromComposition\n        // and deleteByComposition inputType values for the beforeinput event. These are meant to occur\n        // at the end of a composition (e.g. Pinyin IME, Android auto correct, etc.), and crucially, are\n        // cancelable. The insertCompositionText and deleteCompositionText input types are not cancelable,\n        // nor would we want to cancel them because the input from the user is incomplete at that point.\n        // In Safari, insertFromComposition/deleteFromComposition will fire, however, allowing us to cancel\n        // the final composition result if it is invalid. As a fallback for Chrome and Firefox, which either\n        // don't support Input Events Level 2, or beforeinput at all, we store the state of the input when\n        // the compositionstart event fires, and undo the changes in compositionend (below) if it is invalid.\n        // Unfortunately, this messes up the undo/redo stack, but until insertFromComposition/deleteByComposition\n        // are implemented, there is no other way to prevent composed input.\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=1022204\n        let {\n          value: value,\n          selectionStart: selectionStart,\n          selectionEnd: selectionEnd\n        } = inputRef.current;\n        compositionStartState.current = {\n          value: value,\n          selectionStart: selectionStart,\n          selectionEnd: selectionEnd\n        };\n      },\n\n      onCompositionEnd() {\n        if (!state1.validate(inputRef.current.value)) {\n          // Restore the input value in the DOM immediately so we can synchronously update the selection position.\n          // But also update the value in React state as well so it is correct for future updates.\n          let {\n            value: value,\n            selectionStart: selectionStart,\n            selectionEnd: selectionEnd\n          } = compositionStartState.current;\n          inputRef.current.value = value;\n          inputRef.current.setSelectionRange(selectionStart, selectionEnd);\n          state1.setInputValue(value);\n        }\n      }\n\n    }),\n    labelProps: labelProps,\n    descriptionProps: descriptionProps,\n    errorMessageProps: errorMessageProps\n  };\n}\n\nexport { $13fe50aacf882d03$export$712718f7aec83d5 as useTextField, $58c0262056d833d5$export$4f384c9210e583c3 as useFormattedTextField };","map":{"version":3,"mappings":"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","names":["$13fe50aacf882d03$export$712718f7aec83d5","props","ref","inputElementType","isDisabled","isRequired","isReadOnly","validationState","type","onChange","focusableProps","$aywJT$useFocusable","labelProps","fieldProps","descriptionProps","errorMessageProps","$aywJT$useField","domProps","$aywJT$filterDOMProps","labelable","inputOnlyProps","pattern","inputProps","$aywJT$mergeProps","disabled","readOnly","undefined","value","defaultValue","e","target","autoComplete","maxLength","minLength","name","placeholder","inputMode","onCopy","onCut","onPaste","onCompositionEnd","onCompositionStart","onCompositionUpdate","onSelect","onBeforeInput","onInput","$58c0262056d833d5$var$supportsNativeBeforeInputEvent","window","InputEvent","prototype","getTargetRanges","$58c0262056d833d5$export$4f384c9210e583c3","state1","inputRef","stateRef","$aywJT$useRef","current","$aywJT$useEffect","input","state","nextValue","inputType","slice","selectionStart","selectionEnd","data","validate","preventDefault","addEventListener","removeEventListener","onBeforeInput1","textFieldProps","compositionStartState","setSelectionRange","setInputValue"],"sources":["/Users/asattiraju/Desktop/Big data/gt-bigdata-website/node_modules/@react-aria/textfield/dist/packages/@react-aria/textfield/src/useTextField.ts","/Users/asattiraju/Desktop/Big data/gt-bigdata-website/node_modules/@react-aria/textfield/dist/packages/@react-aria/textfield/src/useFormattedTextField.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaTextFieldProps} from '@react-types/textfield';\nimport {\n  ChangeEvent,\n  DOMFactory,\n  HTMLAttributes,\n  LabelHTMLAttributes,\n  ReactDOM,\n  RefObject\n} from 'react';\nimport {filterDOMProps, mergeProps} from '@react-aria/utils';\nimport {useField} from '@react-aria/label';\nimport {useFocusable} from '@react-aria/focus';\n\n/**\n * A map of HTML element names and their interface types.\n * For example `'a'` -> `HTMLAnchorElement`.\n */\ntype IntrinsicHTMLElements = {\n  [K in keyof IntrinsicHTMLAttributes]: IntrinsicHTMLAttributes[K] extends HTMLAttributes<infer T> ? T : never\n};\n\n/**\n * A map of HTML element names and their attribute interface types.\n * For example `'a'` -> `AnchorHTMLAttributes<HTMLAnchorElement>`.\n */\ntype IntrinsicHTMLAttributes = {\n  [K in keyof ReactDOM]: ReactDOM[K] extends DOMFactory<infer T, any> ? T : never\n};\n\ntype DefaultElementType = 'input';\n\n/**\n * The intrinsic HTML element names that `useTextField` supports; e.g. `input`,\n * `textarea`.\n */\ntype TextFieldIntrinsicElements = keyof Pick<IntrinsicHTMLElements, 'input' | 'textarea'>;\n\n /**\n  * The HTML element interfaces that `useTextField` supports based on what is\n  * defined for `TextFieldIntrinsicElements`; e.g. `HTMLInputElement`,\n  * `HTMLTextAreaElement`.\n  */\ntype TextFieldHTMLElementType = Pick<IntrinsicHTMLElements, TextFieldIntrinsicElements>;\n\n /**\n  * The HTML attributes interfaces that `useTextField` supports based on what\n  * is defined for `TextFieldIntrinsicElements`; e.g. `InputHTMLAttributes`,\n  * `TextareaHTMLAttributes`.\n  */\ntype TextFieldHTMLAttributesType = Pick<IntrinsicHTMLAttributes, TextFieldIntrinsicElements>;\n\n/**\n * The type of `inputProps` returned by `useTextField`; e.g. `InputHTMLAttributes`,\n * `TextareaHTMLAttributes`.\n */\ntype TextFieldInputProps<T extends TextFieldIntrinsicElements> = TextFieldHTMLAttributesType[T];\n\ninterface AriaTextFieldOptions<T extends TextFieldIntrinsicElements> extends AriaTextFieldProps {\n  /**\n   * The HTML element used to render the input, e.g. 'input', or 'textarea'.\n   * It determines whether certain HTML attributes will be included in `inputProps`.\n   * For example, [`type`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-type).\n   * @default 'input'\n   */\n  inputElementType?: T\n}\n\n/**\n * The type of `ref` object that can be passed to `useTextField` based on the given\n * intrinsic HTML element name; e.g.`RefObject<HTMLInputElement>`,\n * `RefObject<HTMLTextAreaElement>`.\n */\ntype TextFieldRefObject<T extends TextFieldIntrinsicElements> = RefObject<TextFieldHTMLElementType[T]>;\n\nexport interface TextFieldAria<T extends TextFieldIntrinsicElements = DefaultElementType> {\n  /** Props for the input element. */\n  inputProps: TextFieldInputProps<T>,\n  /** Props for the text field's visible label element, if any. */\n  labelProps: LabelHTMLAttributes<HTMLLabelElement>,\n  /** Props for the text field's description element, if any. */\n  descriptionProps: HTMLAttributes<HTMLElement>,\n  /** Props for the text field's error message element, if any. */\n  errorMessageProps: HTMLAttributes<HTMLElement>\n}\n\n/**\n * Provides the behavior and accessibility implementation for a text field.\n * @param props - Props for the text field.\n * @param ref - Ref to the HTML input or textarea element.\n */\nexport function useTextField<T extends TextFieldIntrinsicElements = DefaultElementType>(\n  props: AriaTextFieldOptions<T>,\n  ref: TextFieldRefObject<T>\n): TextFieldAria<T> {\n  let {\n    inputElementType = 'input',\n    isDisabled = false,\n    isRequired = false,\n    isReadOnly = false,\n    validationState,\n    type = 'text',\n    onChange = () => {}\n  }: AriaTextFieldOptions<TextFieldIntrinsicElements> = props;\n  let {focusableProps} = useFocusable(props, ref);\n  let {labelProps, fieldProps, descriptionProps, errorMessageProps} = useField(props);\n  let domProps = filterDOMProps(props, {labelable: true});\n\n  const inputOnlyProps = {\n    type,\n    pattern: props.pattern\n  };\n\n  return {\n    labelProps,\n    inputProps: mergeProps(\n      domProps,\n      inputElementType === 'input' && inputOnlyProps,\n      {\n        disabled: isDisabled,\n        readOnly: isReadOnly,\n        'aria-required': isRequired || undefined,\n        'aria-invalid': validationState === 'invalid' || undefined,\n        'aria-errormessage': props['aria-errormessage'],\n        'aria-activedescendant': props['aria-activedescendant'],\n        'aria-autocomplete': props['aria-autocomplete'],\n        'aria-haspopup': props['aria-haspopup'],\n        value: props.value,\n        defaultValue: props.value ? undefined : props.defaultValue,\n        onChange: (e: ChangeEvent<HTMLInputElement>) => onChange(e.target.value),\n        autoComplete: props.autoComplete,\n        maxLength: props.maxLength,\n        minLength: props.minLength,\n        name: props.name,\n        placeholder: props.placeholder,\n        inputMode: props.inputMode,\n\n        // Clipboard events\n        onCopy: props.onCopy,\n        onCut: props.onCut,\n        onPaste: props.onPaste,\n\n        // Composition events\n        onCompositionEnd: props.onCompositionEnd,\n        onCompositionStart: props.onCompositionStart,\n        onCompositionUpdate: props.onCompositionUpdate,\n\n        // Selection events\n        onSelect: props.onSelect,\n\n        // Input events\n        onBeforeInput: props.onBeforeInput,\n        onInput: props.onInput,\n        ...focusableProps,\n        ...fieldProps\n      }\n    ),\n    descriptionProps,\n    errorMessageProps\n  };\n}\n","/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaTextFieldProps} from '@react-types/textfield';\nimport {mergeProps} from '@react-aria/utils';\nimport {RefObject, useEffect, useRef} from 'react';\nimport {TextFieldAria, useTextField} from './useTextField';\n\ninterface FormattedTextFieldState {\n  validate: (val: string) => boolean,\n  setInputValue: (val: string) => void\n}\n\n\nfunction supportsNativeBeforeInputEvent() {\n  return typeof window !== 'undefined' &&\n    window.InputEvent &&\n    // @ts-ignore\n    typeof InputEvent.prototype.getTargetRanges === 'function';\n}\n\nexport function useFormattedTextField(props: AriaTextFieldProps, state: FormattedTextFieldState, inputRef: RefObject<HTMLInputElement>): TextFieldAria {\n\n  let stateRef = useRef(state);\n  stateRef.current = state;\n\n  // All browsers implement the 'beforeinput' event natively except Firefox\n  // (currently behind a flag as of Firefox 84). React's polyfill does not\n  // run in all cases that the native event fires, e.g. when deleting text.\n  // Use the native event if available so that we can prevent invalid deletions.\n  // We do not attempt to polyfill this in Firefox since it would be very complicated,\n  // the benefit of doing so is fairly minor, and it's going to be natively supported soon.\n  useEffect(() => {\n    if (!supportsNativeBeforeInputEvent()) {\n      return;\n    }\n\n    let input = inputRef.current;\n\n    let onBeforeInput = (e: InputEvent) => {\n      let state = stateRef.current;\n\n      // Compute the next value of the input if the event is allowed to proceed.\n      // See https://www.w3.org/TR/input-events-2/#interface-InputEvent-Attributes for a full list of input types.\n      let nextValue: string;\n      switch (e.inputType) {\n        case 'historyUndo':\n        case 'historyRedo':\n          // Explicitly allow undo/redo. e.data is null in this case, but there's no need to validate,\n          // because presumably the input would have already been validated previously.\n          return;\n        case 'deleteContent':\n        case 'deleteByCut':\n        case 'deleteByDrag':\n          nextValue = input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);\n          break;\n        case 'deleteContentForward':\n          // This is potentially incorrect, since the browser may actually delete more than a single UTF-16\n          // character. In reality, a full Unicode grapheme cluster consisting of multiple UTF-16 characters\n          // or code points may be deleted. However, in our currently supported locales, there are no such cases.\n          // If we support additional locales in the future, this may need to change.\n          nextValue = input.selectionEnd === input.selectionStart\n            ? input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd + 1)\n            : input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);\n          break;\n        case 'deleteContentBackward':\n          nextValue = input.selectionEnd === input.selectionStart\n            ? input.value.slice(0, input.selectionStart - 1) + input.value.slice(input.selectionStart)\n            : input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);\n          break;\n        case 'deleteSoftLineBackward':\n        case 'deleteHardLineBackward':\n          nextValue = input.value.slice(input.selectionStart);\n          break;\n        default:\n          if (e.data != null) {\n            nextValue =\n              input.value.slice(0, input.selectionStart) +\n              e.data +\n              input.value.slice(input.selectionEnd);\n          }\n          break;\n      }\n\n      // If we did not compute a value, or the new value is invalid, prevent the event\n      // so that the browser does not update the input text, move the selection, or add to\n      // the undo/redo stack.\n      if (nextValue == null || !state.validate(nextValue)) {\n        e.preventDefault();\n      }\n    };\n\n    input.addEventListener('beforeinput', onBeforeInput, false);\n    return () => {\n      input.removeEventListener('beforeinput', onBeforeInput, false);\n    };\n  }, [inputRef, stateRef]);\n\n  let onBeforeInput = !supportsNativeBeforeInputEvent()\n    ? e => {\n      let nextValue =\n        e.target.value.slice(0, e.target.selectionStart) +\n        e.data +\n        e.target.value.slice(e.target.selectionEnd);\n\n      if (!state.validate(nextValue)) {\n        e.preventDefault();\n      }\n    }\n    : null;\n\n  let {labelProps, inputProps: textFieldProps, descriptionProps, errorMessageProps} = useTextField(props, inputRef);\n\n  let compositionStartState = useRef(null);\n  return {\n    inputProps: mergeProps(\n      textFieldProps,\n      {\n        onBeforeInput,\n        onCompositionStart() {\n          // Chrome does not implement Input Events Level 2, which specifies the insertFromComposition\n          // and deleteByComposition inputType values for the beforeinput event. These are meant to occur\n          // at the end of a composition (e.g. Pinyin IME, Android auto correct, etc.), and crucially, are\n          // cancelable. The insertCompositionText and deleteCompositionText input types are not cancelable,\n          // nor would we want to cancel them because the input from the user is incomplete at that point.\n          // In Safari, insertFromComposition/deleteFromComposition will fire, however, allowing us to cancel\n          // the final composition result if it is invalid. As a fallback for Chrome and Firefox, which either\n          // don't support Input Events Level 2, or beforeinput at all, we store the state of the input when\n          // the compositionstart event fires, and undo the changes in compositionend (below) if it is invalid.\n          // Unfortunately, this messes up the undo/redo stack, but until insertFromComposition/deleteByComposition\n          // are implemented, there is no other way to prevent composed input.\n          // See https://bugs.chromium.org/p/chromium/issues/detail?id=1022204\n          let {value, selectionStart, selectionEnd} = inputRef.current;\n          compositionStartState.current = {value, selectionStart, selectionEnd};\n        },\n        onCompositionEnd() {\n          if (!state.validate(inputRef.current.value)) {\n            // Restore the input value in the DOM immediately so we can synchronously update the selection position.\n            // But also update the value in React state as well so it is correct for future updates.\n            let {value, selectionStart, selectionEnd} = compositionStartState.current;\n            inputRef.current.value = value;\n            inputRef.current.setSelectionRange(selectionStart, selectionEnd);\n            state.setInputValue(value);\n          }\n        }\n      }\n    ),\n    labelProps,\n    descriptionProps,\n    errorMessageProps\n  };\n}\n"]},"metadata":{},"sourceType":"module"}