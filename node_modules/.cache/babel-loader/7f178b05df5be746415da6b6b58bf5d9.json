{"ast":null,"code":"import { useMemo as $80DDZ$useMemo, useEffect as $80DDZ$useEffect } from \"react\";\nimport { useMultipleSelectionState as $80DDZ$useMultipleSelectionState, SelectionManager as $80DDZ$SelectionManager } from \"@react-stately/selection\";\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n\nvar $e6fbdaf61ee618ce$exports = {};\n$parcel$export($e6fbdaf61ee618ce$exports, \"useGridState\", () => $e6fbdaf61ee618ce$export$4007ac09ff9c68ed);\n\nfunction $e6fbdaf61ee618ce$export$4007ac09ff9c68ed(props) {\n  let {\n    collection: collection,\n    focusMode: focusMode\n  } = props;\n  let selectionState = $80DDZ$useMultipleSelectionState(props);\n  let disabledKeys = $80DDZ$useMemo(() => props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [props.disabledKeys]);\n  let setFocusedKey = selectionState.setFocusedKey;\n\n  selectionState.setFocusedKey = (key, child) => {\n    // If focusMode is cell and an item is focused, focus a child cell instead.\n    if (focusMode === 'cell' && key != null) {\n      let item = collection.getItem(key);\n\n      if ((item === null || item === void 0 ? void 0 : item.type) === 'item') {\n        var ref, ref1;\n        let children = [...item.childNodes];\n        if (child === 'last') key = (ref = children[children.length - 1]) === null || ref === void 0 ? void 0 : ref.key;else key = (ref1 = children[0]) === null || ref1 === void 0 ? void 0 : ref1.key;\n      }\n    }\n\n    setFocusedKey(key, child);\n  }; // Reset focused key if that item is deleted from the collection.\n\n\n  $80DDZ$useEffect(() => {\n    if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) selectionState.setFocusedKey(null);\n  }, [collection, selectionState.focusedKey]);\n  return {\n    collection: collection,\n    disabledKeys: disabledKeys,\n    selectionManager: new $80DDZ$SelectionManager(collection, selectionState)\n  };\n}\n\nvar $f4613af0bafc7619$exports = {};\n$parcel$export($f4613af0bafc7619$exports, \"GridCollection\", () => $f4613af0bafc7619$export$de3fdf6493c353d);\nvar tmp = Symbol.iterator;\n\nclass $f4613af0bafc7619$export$de3fdf6493c353d {\n  *[tmp]() {\n    yield* [...this.rows];\n  }\n\n  get size() {\n    return [...this.rows].length;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n\n  getKeyAfter(key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n\n  getFirstKey() {\n    var ref;\n    return (ref = [...this.rows][0]) === null || ref === void 0 ? void 0 : ref.key;\n  }\n\n  getLastKey() {\n    var ref;\n    let rows = [...this.rows];\n    return (ref = rows[rows.length - 1]) === null || ref === void 0 ? void 0 : ref.key;\n  }\n\n  getItem(key) {\n    return this.keyMap.get(key);\n  }\n\n  at(idx) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n\n  constructor(opts) {\n    this.keyMap = new Map();\n    this.keyMap = new Map();\n    this.columnCount = opts === null || opts === void 0 ? void 0 : opts.columnCount;\n    this.rows = [];\n\n    let visit = node => {\n      // If the node is the same object as the previous node for the same key,\n      // we can skip this node and its children. We always visit columns though,\n      // because we depend on order to build the columns array.\n      let prevNode = this.keyMap.get(node.key);\n      if (opts.visitNode) node = opts.visitNode(node);\n      this.keyMap.set(node.key, node);\n      let childKeys = new Set();\n      let last;\n\n      for (let child of node.childNodes) {\n        if (child.type === 'cell' && child.parentKey == null) // if child is a cell parent key isn't already established by the collection, match child node to parent row\n          child.parentKey = node.key;\n        childKeys.add(child.key);\n\n        if (last) {\n          last.nextKey = child.key;\n          child.prevKey = last.key;\n        } else child.prevKey = null;\n\n        visit(child);\n        last = child;\n      }\n\n      if (last) last.nextKey = null; // Remove deleted nodes and their children from the key map\n\n      if (prevNode) {\n        for (let child of prevNode.childNodes) if (!childKeys.has(child.key)) remove(child);\n      }\n    };\n\n    let remove = node => {\n      this.keyMap.delete(node.key);\n\n      for (let child of node.childNodes) if (this.keyMap.get(child.key) === child) remove(child);\n    };\n\n    let last1;\n    opts.items.forEach((node, i) => {\n      let rowNode = {\n        level: 0,\n        key: 'row-' + i,\n        type: 'row',\n        value: undefined,\n        hasChildNodes: true,\n        childNodes: [...node.childNodes],\n        rendered: undefined,\n        textValue: undefined,\n        ...node,\n        index: i\n      };\n\n      if (last1) {\n        last1.nextKey = rowNode.key;\n        rowNode.prevKey = last1.key;\n      } else rowNode.prevKey = null;\n\n      this.rows.push(rowNode);\n      visit(rowNode);\n      last1 = rowNode;\n    });\n    if (last1) last1.nextKey = null;\n  }\n\n}\n\nexport { $e6fbdaf61ee618ce$export$4007ac09ff9c68ed as useGridState, $f4613af0bafc7619$export$de3fdf6493c353d as GridCollection };","map":{"version":3,"mappings":"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","names":["$e6fbdaf61ee618ce$export$4007ac09ff9c68ed","props","collection","focusMode","selectionState","$80DDZ$useMultipleSelectionState","disabledKeys","$80DDZ$useMemo","Set","setFocusedKey","key","child","item","getItem","type","ref","ref1","children","childNodes","length","$80DDZ$useEffect","focusedKey","selectionManager","$80DDZ$SelectionManager","Symbol","iterator","$f4613af0bafc7619$export$de3fdf6493c353d","rows","size","getKeys","keyMap","keys","getKeyBefore","node","get","prevKey","getKeyAfter","nextKey","getFirstKey","getLastKey","at","idx","opts","Map","columnCount","visit","prevNode","visitNode","set","childKeys","last","parentKey","add","has","remove","delete","last1","items","forEach","i","rowNode","level","value","undefined","hasChildNodes","rendered","textValue","index","push"],"sources":["/Users/asattiraju/Desktop/gt-bigdata-website/node_modules/@react-stately/grid/dist/packages/@react-stately/grid/src/useGridState.ts","/Users/asattiraju/Desktop/gt-bigdata-website/node_modules/@react-stately/grid/dist/packages/@react-stately/grid/src/GridCollection.ts"],"sourcesContent":["import {GridCollection} from '@react-types/grid';\nimport {Key, useEffect, useMemo} from 'react';\nimport {MultipleSelectionStateProps, SelectionManager, useMultipleSelectionState} from '@react-stately/selection';\n\nexport interface GridState<T, C extends GridCollection<T>> {\n  collection: C,\n  /** A set of keys for rows that are disabled. */\n  disabledKeys: Set<Key>,\n  /** A selection manager to read and update row selection state. */\n  selectionManager: SelectionManager\n}\n\ninterface GridStateOptions<T, C extends GridCollection<T>> extends MultipleSelectionStateProps {\n  collection: C,\n  disabledKeys?: Iterable<Key>,\n  focusMode?: 'row' | 'cell'\n}\n\n/**\n * Provides state management for a grid component. Handles row selection and focusing a grid cell's focusable child if applicable.\n */\nexport function useGridState<T extends object, C extends GridCollection<T>>(props: GridStateOptions<T, C>): GridState<T, C> {\n  let {collection, focusMode} = props;\n  let selectionState = useMultipleSelectionState(props);\n  let disabledKeys = useMemo(() =>\n      props.disabledKeys ? new Set(props.disabledKeys) : new Set<Key>()\n    , [props.disabledKeys]);\n\n  let setFocusedKey = selectionState.setFocusedKey;\n  selectionState.setFocusedKey = (key, child) => {\n    // If focusMode is cell and an item is focused, focus a child cell instead.\n    if (focusMode === 'cell' && key != null) {\n      let item = collection.getItem(key);\n      if (item?.type === 'item') {\n        let children = [...item.childNodes];\n        if (child === 'last') {\n          key = children[children.length - 1]?.key;\n        } else {\n          key = children[0]?.key;\n        }\n      }\n    }\n\n    setFocusedKey(key, child);\n  };\n\n  // Reset focused key if that item is deleted from the collection.\n  useEffect(() => {\n    if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n      selectionState.setFocusedKey(null);\n    }\n  }, [collection, selectionState.focusedKey]);\n\n  return {\n    collection,\n    disabledKeys,\n    selectionManager: new SelectionManager(collection, selectionState)\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport {GridNode, GridRow, GridCollection as IGridCollection} from '@react-types/grid';\nimport {Key} from 'react';\n\n\ninterface GridCollectionOptions<T> {\n  columnCount: number,\n  items: GridRow<T>[],\n  visitNode?: (cell: GridNode<T>) => GridNode<T>\n}\n\nexport class GridCollection<T> implements IGridCollection<T> {\n  keyMap: Map<Key, GridNode<T>> = new Map();\n  columnCount: number;\n  rows: GridNode<T>[];\n\n  constructor(opts?: GridCollectionOptions<T>) {\n    this.keyMap = new Map();\n    this.columnCount = opts?.columnCount;\n    this.rows = [];\n\n    let visit = (node: GridNode<T>) => {\n      // If the node is the same object as the previous node for the same key,\n      // we can skip this node and its children. We always visit columns though,\n      // because we depend on order to build the columns array.\n      let prevNode = this.keyMap.get(node.key);\n      if (opts.visitNode) {\n        node = opts.visitNode(node);\n      }\n\n      this.keyMap.set(node.key, node);\n\n      let childKeys = new Set();\n      let last: GridNode<T>;\n      for (let child of node.childNodes) {\n        if (child.type === 'cell' && child.parentKey == null) {\n          // if child is a cell parent key isn't already established by the collection, match child node to parent row\n          child.parentKey = node.key;\n        }\n        childKeys.add(child.key);\n\n        if (last) {\n          last.nextKey = child.key;\n          child.prevKey = last.key;\n        } else {\n          child.prevKey = null;\n        }\n\n        visit(child);\n        last = child;\n      }\n\n      if (last) {\n        last.nextKey = null;\n      }\n\n      // Remove deleted nodes and their children from the key map\n      if (prevNode) {\n        for (let child of prevNode.childNodes) {\n          if (!childKeys.has(child.key)) {\n            remove(child);\n          }\n        }\n      }\n    };\n\n    let remove = (node: GridNode<T>) => {\n      this.keyMap.delete(node.key);\n      for (let child of node.childNodes) {\n        if (this.keyMap.get(child.key) === child) {\n          remove(child);\n        }\n      }\n    };\n\n    let last: GridNode<T>;\n    opts.items.forEach((node, i) => {\n      let rowNode = {\n        level: 0,\n        key: 'row-' + i,\n        type: 'row',\n        value: undefined,\n        hasChildNodes: true,\n        childNodes: [...node.childNodes],\n        rendered: undefined,\n        textValue: undefined,\n        ...node,\n        index: i\n      } as GridNode<T>;\n\n      if (last) {\n        last.nextKey = rowNode.key;\n        rowNode.prevKey = last.key;\n      } else {\n        rowNode.prevKey = null;\n      }\n\n      this.rows.push(rowNode);\n      visit(rowNode);\n\n      last = rowNode;\n    });\n\n    if (last) {\n      last.nextKey = null;\n    }\n  }\n\n  *[Symbol.iterator]() {\n    yield* [...this.rows];\n  }\n\n  get size() {\n    return [...this.rows].length;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n\n  getKeyAfter(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n\n  getFirstKey() {\n    return [...this.rows][0]?.key;\n  }\n\n  getLastKey() {\n    let rows = [...this.rows];\n    return rows[rows.length - 1]?.key;\n  }\n\n  getItem(key: Key) {\n    return this.keyMap.get(key);\n  }\n\n  at(idx: number) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}