{"ast":null,"code":"import { useControlledState as $k3hqg$useControlledState, clamp as $k3hqg$clamp, snapValueToStep as $k3hqg$snapValueToStep } from \"@react-stately/utils\";\nimport { NumberFormatter as $k3hqg$NumberFormatter, NumberParser as $k3hqg$NumberParser } from \"@internationalized/number\";\nimport { useState as $k3hqg$useState, useMemo as $k3hqg$useMemo, useCallback as $k3hqg$useCallback, useEffect as $k3hqg$useEffect, useRef as $k3hqg$useRef } from \"react\";\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n\nvar $9f327308a7d514e5$exports = {};\n$parcel$export($9f327308a7d514e5$exports, \"useNumberFieldState\", () => $9f327308a7d514e5$export$7f629e9dc1ecf37c);\n\nfunction $9f327308a7d514e5$export$7f629e9dc1ecf37c(props) {\n  let {\n    minValue: minValue,\n    maxValue: maxValue,\n    step: step,\n    formatOptions: formatOptions,\n    value: value1,\n    defaultValue: defaultValue,\n    onChange: onChange,\n    locale: locale,\n    isDisabled: isDisabled,\n    isReadOnly: isReadOnly\n  } = props;\n  let [numberValue, setNumberValue] = $k3hqg$useControlledState(value1, isNaN(defaultValue) ? NaN : defaultValue, onChange);\n  let [inputValue, setInputValue] = $k3hqg$useState(() => isNaN(numberValue) ? '' : new $k3hqg$NumberFormatter(locale, formatOptions).format(numberValue));\n  let numberParser = $k3hqg$useMemo(() => new $k3hqg$NumberParser(locale, formatOptions), [locale, formatOptions]);\n  let numberingSystem = $k3hqg$useMemo(() => numberParser.getNumberingSystem(inputValue), [numberParser, inputValue]);\n  let formatter = $k3hqg$useMemo(() => new $k3hqg$NumberFormatter(locale, { ...formatOptions,\n    numberingSystem: numberingSystem\n  }), [locale, formatOptions, numberingSystem]);\n  let intlOptions = $k3hqg$useMemo(() => formatter.resolvedOptions(), [formatter]);\n  let format = $k3hqg$useCallback(value => isNaN(value) ? '' : formatter.format(value), [formatter]);\n  let clampStep = !isNaN(step) ? step : 1;\n  if (intlOptions.style === 'percent' && isNaN(step)) clampStep = 0.01; // Update the input value when the number value or format options change. This is done\n  // in a useEffect so that the controlled behavior is correct and we only update the\n  // textfield after prop changes.\n\n  $k3hqg$useEffect(() => {\n    setInputValue(format(numberValue));\n  }, [numberValue, locale, formatOptions]); // Store last parsed value in a ref so it can be used by increment/decrement below\n\n  let parsedValue = $k3hqg$useMemo(() => numberParser.parse(inputValue), [numberParser, inputValue]);\n  let parsed = $k3hqg$useRef(0);\n  parsed.current = parsedValue;\n\n  let commit = () => {\n    // Set to empty state if input value is empty\n    if (!inputValue.length) {\n      setNumberValue(NaN);\n      setInputValue(value1 === undefined ? '' : format(numberValue));\n      return;\n    } // if it failed to parse, then reset input to formatted version of current number\n\n\n    if (isNaN(parsed.current)) {\n      setInputValue(format(numberValue));\n      return;\n    } // Clamp to min and max, round to the nearest step, and round to specified number of digits\n\n\n    let clampedValue;\n    if (isNaN(step)) clampedValue = $k3hqg$clamp(parsed.current, minValue, maxValue);else clampedValue = $k3hqg$snapValueToStep(parsed.current, minValue, maxValue, step);\n    clampedValue = numberParser.parse(format(clampedValue));\n    setNumberValue(clampedValue); // in a controlled state, the numberValue won't change, so we won't go back to our old input without help\n\n    setInputValue(format(value1 === undefined ? clampedValue : numberValue));\n  };\n\n  let safeNextStep = (operation, minMax) => {\n    let prev = parsed.current;\n\n    if (isNaN(prev)) {\n      // if the input is empty, start from the min/max value when incrementing/decrementing,\n      // or zero if there is no min/max value defined.\n      let newValue = isNaN(minMax) ? 0 : minMax;\n      return $k3hqg$snapValueToStep(newValue, minValue, maxValue, clampStep);\n    } else {\n      // otherwise, first snap the current value to the nearest step. if it moves in the direction\n      // we're going, use that value, otherwise add the step and snap that value.\n      let newValue = $k3hqg$snapValueToStep(prev, minValue, maxValue, clampStep);\n      if (operation === '+' && newValue > prev || operation === '-' && newValue < prev) return newValue;\n      return $k3hqg$snapValueToStep($9f327308a7d514e5$var$handleDecimalOperation(operation, prev, clampStep), minValue, maxValue, clampStep);\n    }\n  };\n\n  let increment = () => {\n    let newValue = safeNextStep('+', minValue); // if we've arrived at the same value that was previously in the state, the\n    // input value should be updated to match\n    // ex type 4, press increment, highlight the number in the input, type 4 again, press increment\n    // you'd be at 5, then incrementing to 5 again, so no re-render would happen and 4 would be left in the input\n\n    if (newValue === numberValue) setInputValue(format(newValue));\n    setNumberValue(newValue);\n  };\n\n  let decrement = () => {\n    let newValue = safeNextStep('-', maxValue);\n    if (newValue === numberValue) setInputValue(format(newValue));\n    setNumberValue(newValue);\n  };\n\n  let incrementToMax = () => {\n    if (maxValue != null) setNumberValue($k3hqg$snapValueToStep(maxValue, minValue, maxValue, clampStep));\n  };\n\n  let decrementToMin = () => {\n    if (minValue != null) setNumberValue(minValue);\n  };\n\n  let canIncrement = $k3hqg$useMemo(() => !isDisabled && !isReadOnly && (isNaN(parsedValue) || isNaN(maxValue) || $k3hqg$snapValueToStep(parsedValue, minValue, maxValue, clampStep) > parsedValue || $9f327308a7d514e5$var$handleDecimalOperation('+', parsedValue, clampStep) <= maxValue), [isDisabled, isReadOnly, minValue, maxValue, clampStep, parsedValue]);\n  let canDecrement = $k3hqg$useMemo(() => !isDisabled && !isReadOnly && (isNaN(parsedValue) || isNaN(minValue) || $k3hqg$snapValueToStep(parsedValue, minValue, maxValue, clampStep) < parsedValue || $9f327308a7d514e5$var$handleDecimalOperation('-', parsedValue, clampStep) >= minValue), [isDisabled, isReadOnly, minValue, maxValue, clampStep, parsedValue]);\n\n  let validate = value => numberParser.isValidPartialNumber(value, minValue, maxValue);\n\n  return {\n    validate: validate,\n    increment: increment,\n    incrementToMax: incrementToMax,\n    decrement: decrement,\n    decrementToMin: decrementToMin,\n    canIncrement: canIncrement,\n    canDecrement: canDecrement,\n    minValue: minValue,\n    maxValue: maxValue,\n    numberValue: parsedValue,\n    setInputValue: setInputValue,\n    inputValue: inputValue,\n    commit: commit\n  };\n}\n\nfunction $9f327308a7d514e5$var$handleDecimalOperation(operator, value1, value2) {\n  let result = operator === '+' ? value1 + value2 : value1 - value2; // Check if we have decimals\n\n  if (value1 % 1 !== 0 || value2 % 1 !== 0) {\n    const value1Decimal = value1.toString().split('.');\n    const value2Decimal = value2.toString().split('.');\n    const value1DecimalLength = value1Decimal[1] && value1Decimal[1].length || 0;\n    const value2DecimalLength = value2Decimal[1] && value2Decimal[1].length || 0;\n    const multiplier = Math.pow(10, Math.max(value1DecimalLength, value2DecimalLength)); // Transform the decimals to integers based on the precision\n\n    value1 = Math.round(value1 * multiplier);\n    value2 = Math.round(value2 * multiplier); // Perform the operation on integers values to make sure we don't get a fancy decimal value\n\n    result = operator === '+' ? value1 + value2 : value1 - value2; // Transform the integer result back to decimal\n\n    result /= multiplier;\n  }\n\n  return result;\n}\n\nexport { $9f327308a7d514e5$export$7f629e9dc1ecf37c as useNumberFieldState };","map":{"version":3,"mappings":"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","names":["$9f327308a7d514e5$export$7f629e9dc1ecf37c","props","minValue","maxValue","step","formatOptions","value","value1","defaultValue","onChange","locale","isDisabled","isReadOnly","numberValue","setNumberValue","$k3hqg$useControlledState","isNaN","NaN","inputValue","setInputValue","$k3hqg$useState","$k3hqg$NumberFormatter","format","numberParser","$k3hqg$useMemo","$k3hqg$NumberParser","numberingSystem","getNumberingSystem","formatter","intlOptions","resolvedOptions","$k3hqg$useCallback","clampStep","style","$k3hqg$useEffect","parsedValue","parse","parsed","$k3hqg$useRef","current","commit","length","undefined","clampedValue","$k3hqg$clamp","$k3hqg$snapValueToStep","safeNextStep","operation","minMax","prev","newValue","$9f327308a7d514e5$var$handleDecimalOperation","increment","decrement","incrementToMax","decrementToMin","canIncrement","canDecrement","validate","isValidPartialNumber","operator","value2","result","value1Decimal","toString","split","value2Decimal","value1DecimalLength","value2DecimalLength","multiplier","Math","pow","max","round"],"sources":["/Users/asattiraju/Desktop/Big data/gt-bigdata-website/node_modules/@react-stately/numberfield/dist/packages/@react-stately/numberfield/src/useNumberFieldState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {clamp, snapValueToStep, useControlledState} from '@react-stately/utils';\nimport {NumberFieldProps} from '@react-types/numberfield';\nimport {NumberFormatter, NumberParser} from '@internationalized/number';\nimport {useCallback, useEffect, useMemo, useRef, useState} from 'react';\n\nexport interface NumberFieldState {\n  /**\n   * The current text value of the input. Updated as the user types,\n   * and formatted according to `formatOptions` on blur.\n   */\n  inputValue: string,\n  /**\n   * The currently parsed number value, or NaN if a valid number could not be parsed.\n   * Updated based on the `inputValue` as the user types.\n   */\n  numberValue: number,\n  /** The minimum value of the number field. */\n  minValue: number,\n  /** The maximum value of the number field. */\n  maxValue: number,\n  /** Whether the current value can be incremented according to the maximum value and step. */\n  canIncrement: boolean,\n  /** Whether the current value can be decremented according to the minimum value and step. */\n  canDecrement: boolean,\n  /**\n   * Validates a user input string according to the current locale and format options.\n   * Values can be partially entered, and may be valid even if they cannot currently be parsed to a number.\n   * Can be used to implement validation as a user types.\n   */\n  validate(value: string): boolean,\n  /** Sets the current text value of the input. */\n  setInputValue(val: string): void,\n  /**\n   * Commits the current input value. The value is parsed to a number, clamped according\n   * to the minimum and maximum values of the field, and snapped to the nearest step value.\n   * This will fire the `onChange` prop with the new value, and if uncontrolled, update the `numberValue`.\n   * Typically this is called when the field is blurred.\n   */\n  commit(): void,\n  /** Increments the current input value to the next step boundary, and fires `onChange`. */\n  increment(): void,\n  /** Decrements the current input value to the next step boundary, and fires `onChange`. */\n  decrement(): void,\n  /** Sets the current value to the `maxValue` if any, and fires `onChange`. */\n  incrementToMax(): void,\n  /** Sets the current value to the `minValue` if any, and fires `onChange`. */\n  decrementToMin(): void\n}\n\ninterface NumberFieldStateProps extends NumberFieldProps {\n  /**\n   * The locale that should be used for parsing.\n   * @default 'en-US'\n   */\n  locale: string\n}\n\n/**\n * Provides state management for a number field component. Number fields allow users to enter a number,\n * and increment or decrement the value using stepper buttons.\n */\nexport function useNumberFieldState(\n  props: NumberFieldStateProps\n): NumberFieldState {\n  let {\n    minValue,\n    maxValue,\n    step,\n    formatOptions,\n    value,\n    defaultValue,\n    onChange,\n    locale,\n    isDisabled,\n    isReadOnly\n  } = props;\n\n  let [numberValue, setNumberValue] = useControlledState<number>(value, isNaN(defaultValue) ? NaN : defaultValue, onChange);\n  let [inputValue, setInputValue] = useState(() => isNaN(numberValue) ? '' : new NumberFormatter(locale, formatOptions).format(numberValue));\n\n  let numberParser = useMemo(() => new NumberParser(locale, formatOptions), [locale, formatOptions]);\n  let numberingSystem = useMemo(() => numberParser.getNumberingSystem(inputValue), [numberParser, inputValue]);\n  let formatter = useMemo(() => new NumberFormatter(locale, {...formatOptions, numberingSystem}), [locale, formatOptions, numberingSystem]);\n  let intlOptions = useMemo(() => formatter.resolvedOptions(), [formatter]);\n  let format = useCallback((value: number) => isNaN(value) ? '' : formatter.format(value), [formatter]);\n\n  let clampStep = !isNaN(step) ? step : 1;\n  if (intlOptions.style === 'percent' && isNaN(step)) {\n    clampStep = 0.01;\n  }\n\n  // Update the input value when the number value or format options change. This is done\n  // in a useEffect so that the controlled behavior is correct and we only update the\n  // textfield after prop changes.\n  useEffect(() => {\n    setInputValue(format(numberValue));\n  }, [numberValue, locale, formatOptions]);\n\n  // Store last parsed value in a ref so it can be used by increment/decrement below\n  let parsedValue = useMemo(() => numberParser.parse(inputValue), [numberParser, inputValue]);\n  let parsed = useRef(0);\n  parsed.current = parsedValue;\n\n  let commit = () => {\n    // Set to empty state if input value is empty\n    if (!inputValue.length) {\n      setNumberValue(NaN);\n      setInputValue(value === undefined ? '' : format(numberValue));\n      return;\n    }\n\n    // if it failed to parse, then reset input to formatted version of current number\n    if (isNaN(parsed.current)) {\n      setInputValue(format(numberValue));\n      return;\n    }\n\n    // Clamp to min and max, round to the nearest step, and round to specified number of digits\n    let clampedValue: number;\n    if (isNaN(step)) {\n      clampedValue = clamp(parsed.current, minValue, maxValue);\n    } else {\n      clampedValue = snapValueToStep(parsed.current, minValue, maxValue, step);\n    }\n\n    clampedValue = numberParser.parse(format(clampedValue));\n    setNumberValue(clampedValue);\n\n    // in a controlled state, the numberValue won't change, so we won't go back to our old input without help\n    setInputValue(format(value === undefined ? clampedValue : numberValue));\n  };\n\n  let safeNextStep = (operation: '+' | '-', minMax: number) => {\n    let prev = parsed.current;\n\n    if (isNaN(prev)) {\n      // if the input is empty, start from the min/max value when incrementing/decrementing,\n      // or zero if there is no min/max value defined.\n      let newValue = isNaN(minMax) ? 0 : minMax;\n      return snapValueToStep(newValue, minValue, maxValue, clampStep);\n    } else {\n      // otherwise, first snap the current value to the nearest step. if it moves in the direction\n      // we're going, use that value, otherwise add the step and snap that value.\n      let newValue = snapValueToStep(prev, minValue, maxValue, clampStep);\n      if ((operation === '+' && newValue > prev) || (operation === '-' && newValue < prev)) {\n        return newValue;\n      }\n\n      return snapValueToStep(\n        handleDecimalOperation(operation, prev, clampStep),\n        minValue,\n        maxValue,\n        clampStep\n      );\n    }\n  };\n\n  let increment = () => {\n    let newValue = safeNextStep('+', minValue);\n\n    // if we've arrived at the same value that was previously in the state, the\n    // input value should be updated to match\n    // ex type 4, press increment, highlight the number in the input, type 4 again, press increment\n    // you'd be at 5, then incrementing to 5 again, so no re-render would happen and 4 would be left in the input\n    if (newValue === numberValue) {\n      setInputValue(format(newValue));\n    }\n\n    setNumberValue(newValue);\n  };\n\n  let decrement = () => {\n    let newValue = safeNextStep('-', maxValue);\n\n    if (newValue === numberValue) {\n      setInputValue(format(newValue));\n    }\n\n    setNumberValue(newValue);\n  };\n\n  let incrementToMax = () => {\n    if (maxValue != null) {\n      setNumberValue(snapValueToStep(maxValue, minValue, maxValue, clampStep));\n    }\n  };\n\n  let decrementToMin = () => {\n    if (minValue != null) {\n      setNumberValue(minValue);\n    }\n  };\n\n  let canIncrement = useMemo(() => (\n    !isDisabled &&\n    !isReadOnly &&\n    (\n      isNaN(parsedValue) ||\n      isNaN(maxValue) ||\n      snapValueToStep(parsedValue, minValue, maxValue, clampStep) > parsedValue ||\n      handleDecimalOperation('+', parsedValue, clampStep) <= maxValue\n    )\n  ), [isDisabled, isReadOnly, minValue, maxValue, clampStep, parsedValue]);\n\n  let canDecrement = useMemo(() => (\n    !isDisabled &&\n    !isReadOnly &&\n    (\n      isNaN(parsedValue) ||\n      isNaN(minValue) ||\n      snapValueToStep(parsedValue, minValue, maxValue, clampStep) < parsedValue ||\n      handleDecimalOperation('-', parsedValue, clampStep) >= minValue\n    )\n  ), [isDisabled, isReadOnly, minValue, maxValue, clampStep, parsedValue]);\n\n  let validate = (value: string) => numberParser.isValidPartialNumber(value, minValue, maxValue);\n\n  return {\n    validate,\n    increment,\n    incrementToMax,\n    decrement,\n    decrementToMin,\n    canIncrement,\n    canDecrement,\n    minValue,\n    maxValue,\n    numberValue: parsedValue,\n    setInputValue,\n    inputValue,\n    commit\n  };\n}\n\nfunction handleDecimalOperation(operator: '-' | '+', value1: number, value2: number): number {\n  let result = operator === '+' ? value1 + value2 : value1 - value2;\n\n  // Check if we have decimals\n  if (value1 % 1 !== 0 || value2 % 1 !== 0) {\n    const value1Decimal = value1.toString().split('.');\n    const value2Decimal = value2.toString().split('.');\n    const value1DecimalLength = (value1Decimal[1] && value1Decimal[1].length) || 0;\n    const value2DecimalLength = (value2Decimal[1] && value2Decimal[1].length) || 0;\n    const multiplier = Math.pow(10, Math.max(value1DecimalLength, value2DecimalLength));\n\n    // Transform the decimals to integers based on the precision\n    value1 = Math.round(value1 * multiplier);\n    value2 = Math.round(value2 * multiplier);\n\n    // Perform the operation on integers values to make sure we don't get a fancy decimal value\n    result = operator === '+' ? value1 + value2 : value1 - value2;\n\n    // Transform the integer result back to decimal\n    result /= multiplier;\n  }\n\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}