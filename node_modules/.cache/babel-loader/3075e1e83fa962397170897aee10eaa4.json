{"ast":null,"code":"import { useControlledState as $vhjCi$useControlledState, clamp as $vhjCi$clamp, snapValueToStep as $vhjCi$snapValueToStep } from \"@react-stately/utils\";\nimport { NumberFormatter as $vhjCi$NumberFormatter, NumberParser as $vhjCi$NumberParser } from \"@internationalized/number\";\nimport { useState as $vhjCi$useState, useMemo as $vhjCi$useMemo, useCallback as $vhjCi$useCallback, useRef as $vhjCi$useRef } from \"react\";\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n\nvar $de67e98908f0c6ee$exports = {};\n$parcel$export($de67e98908f0c6ee$exports, \"useNumberFieldState\", () => $de67e98908f0c6ee$export$7f629e9dc1ecf37c);\n\nfunction $de67e98908f0c6ee$export$7f629e9dc1ecf37c(props) {\n  let {\n    minValue: minValue,\n    maxValue: maxValue,\n    step: step,\n    formatOptions: formatOptions,\n    value: value1,\n    defaultValue: defaultValue,\n    onChange: onChange,\n    locale: locale,\n    isDisabled: isDisabled,\n    isReadOnly: isReadOnly\n  } = props;\n  let [numberValue, setNumberValue] = $vhjCi$useControlledState(value1, isNaN(defaultValue) ? NaN : defaultValue, onChange);\n  let [inputValue, setInputValue] = $vhjCi$useState(() => isNaN(numberValue) ? '' : new $vhjCi$NumberFormatter(locale, formatOptions).format(numberValue));\n  let numberParser = $vhjCi$useMemo(() => new $vhjCi$NumberParser(locale, formatOptions), [locale, formatOptions]);\n  let numberingSystem = $vhjCi$useMemo(() => numberParser.getNumberingSystem(inputValue), [numberParser, inputValue]);\n  let formatter = $vhjCi$useMemo(() => new $vhjCi$NumberFormatter(locale, { ...formatOptions,\n    numberingSystem: numberingSystem\n  }), [locale, formatOptions, numberingSystem]);\n  let intlOptions = $vhjCi$useMemo(() => formatter.resolvedOptions(), [formatter]);\n  let format = $vhjCi$useCallback(value => isNaN(value) ? '' : formatter.format(value), [formatter]);\n  let clampStep = !isNaN(step) ? step : 1;\n  if (intlOptions.style === 'percent' && isNaN(step)) clampStep = 0.01; // Update the input value when the number value or format options change. This is done\n  // in a useEffect so that the controlled behavior is correct and we only update the\n  // textfield after prop changes.\n\n  let prevValue = $vhjCi$useRef(numberValue);\n  let prevLocale = $vhjCi$useRef(locale);\n  let prevFormatOptions = $vhjCi$useRef(formatOptions);\n\n  if (!Object.is(numberValue, prevValue.current) || locale !== prevLocale.current || formatOptions !== prevFormatOptions.current) {\n    setInputValue(format(numberValue));\n    prevValue.current = numberValue;\n    prevLocale.current = locale;\n    prevFormatOptions.current = formatOptions;\n  } // Store last parsed value in a ref so it can be used by increment/decrement below\n\n\n  let parsedValue = $vhjCi$useMemo(() => numberParser.parse(inputValue), [numberParser, inputValue]);\n  let parsed = $vhjCi$useRef(0);\n  parsed.current = parsedValue;\n\n  let commit = () => {\n    // Set to empty state if input value is empty\n    if (!inputValue.length) {\n      setNumberValue(NaN);\n      setInputValue(value1 === undefined ? '' : format(numberValue));\n      return;\n    } // if it failed to parse, then reset input to formatted version of current number\n\n\n    if (isNaN(parsed.current)) {\n      setInputValue(format(numberValue));\n      return;\n    } // Clamp to min and max, round to the nearest step, and round to specified number of digits\n\n\n    let clampedValue;\n    if (isNaN(step)) clampedValue = $vhjCi$clamp(parsed.current, minValue, maxValue);else clampedValue = $vhjCi$snapValueToStep(parsed.current, minValue, maxValue, step);\n    clampedValue = numberParser.parse(format(clampedValue));\n    setNumberValue(clampedValue); // in a controlled state, the numberValue won't change, so we won't go back to our old input without help\n\n    setInputValue(format(value1 === undefined ? clampedValue : numberValue));\n  };\n\n  let safeNextStep = (operation, minMax) => {\n    let prev = parsed.current;\n\n    if (isNaN(prev)) {\n      // if the input is empty, start from the min/max value when incrementing/decrementing,\n      // or zero if there is no min/max value defined.\n      let newValue = isNaN(minMax) ? 0 : minMax;\n      return $vhjCi$snapValueToStep(newValue, minValue, maxValue, clampStep);\n    } else {\n      // otherwise, first snap the current value to the nearest step. if it moves in the direction\n      // we're going, use that value, otherwise add the step and snap that value.\n      let newValue = $vhjCi$snapValueToStep(prev, minValue, maxValue, clampStep);\n      if (operation === '+' && newValue > prev || operation === '-' && newValue < prev) return newValue;\n      return $vhjCi$snapValueToStep($de67e98908f0c6ee$var$handleDecimalOperation(operation, prev, clampStep), minValue, maxValue, clampStep);\n    }\n  };\n\n  let increment = () => {\n    let newValue = safeNextStep('+', minValue); // if we've arrived at the same value that was previously in the state, the\n    // input value should be updated to match\n    // ex type 4, press increment, highlight the number in the input, type 4 again, press increment\n    // you'd be at 5, then incrementing to 5 again, so no re-render would happen and 4 would be left in the input\n\n    if (newValue === numberValue) setInputValue(format(newValue));\n    setNumberValue(newValue);\n  };\n\n  let decrement = () => {\n    let newValue = safeNextStep('-', maxValue);\n    if (newValue === numberValue) setInputValue(format(newValue));\n    setNumberValue(newValue);\n  };\n\n  let incrementToMax = () => {\n    if (maxValue != null) setNumberValue($vhjCi$snapValueToStep(maxValue, minValue, maxValue, clampStep));\n  };\n\n  let decrementToMin = () => {\n    if (minValue != null) setNumberValue(minValue);\n  };\n\n  let canIncrement = $vhjCi$useMemo(() => !isDisabled && !isReadOnly && (isNaN(parsedValue) || isNaN(maxValue) || $vhjCi$snapValueToStep(parsedValue, minValue, maxValue, clampStep) > parsedValue || $de67e98908f0c6ee$var$handleDecimalOperation('+', parsedValue, clampStep) <= maxValue), [isDisabled, isReadOnly, minValue, maxValue, clampStep, parsedValue]);\n  let canDecrement = $vhjCi$useMemo(() => !isDisabled && !isReadOnly && (isNaN(parsedValue) || isNaN(minValue) || $vhjCi$snapValueToStep(parsedValue, minValue, maxValue, clampStep) < parsedValue || $de67e98908f0c6ee$var$handleDecimalOperation('-', parsedValue, clampStep) >= minValue), [isDisabled, isReadOnly, minValue, maxValue, clampStep, parsedValue]);\n\n  let validate = value => numberParser.isValidPartialNumber(value, minValue, maxValue);\n\n  return {\n    validate: validate,\n    increment: increment,\n    incrementToMax: incrementToMax,\n    decrement: decrement,\n    decrementToMin: decrementToMin,\n    canIncrement: canIncrement,\n    canDecrement: canDecrement,\n    minValue: minValue,\n    maxValue: maxValue,\n    numberValue: parsedValue,\n    setInputValue: setInputValue,\n    inputValue: inputValue,\n    commit: commit\n  };\n}\n\nfunction $de67e98908f0c6ee$var$handleDecimalOperation(operator, value1, value2) {\n  let result = operator === '+' ? value1 + value2 : value1 - value2; // Check if we have decimals\n\n  if (value1 % 1 !== 0 || value2 % 1 !== 0) {\n    const value1Decimal = value1.toString().split('.');\n    const value2Decimal = value2.toString().split('.');\n    const value1DecimalLength = value1Decimal[1] && value1Decimal[1].length || 0;\n    const value2DecimalLength = value2Decimal[1] && value2Decimal[1].length || 0;\n    const multiplier = Math.pow(10, Math.max(value1DecimalLength, value2DecimalLength)); // Transform the decimals to integers based on the precision\n\n    value1 = Math.round(value1 * multiplier);\n    value2 = Math.round(value2 * multiplier); // Perform the operation on integers values to make sure we don't get a fancy decimal value\n\n    result = operator === '+' ? value1 + value2 : value1 - value2; // Transform the integer result back to decimal\n\n    result /= multiplier;\n  }\n\n  return result;\n}\n\nexport { $de67e98908f0c6ee$export$7f629e9dc1ecf37c as useNumberFieldState };","map":{"version":3,"mappings":"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","names":["$de67e98908f0c6ee$export$7f629e9dc1ecf37c","props","minValue","maxValue","step","formatOptions","value","value1","defaultValue","onChange","locale","isDisabled","isReadOnly","numberValue","setNumberValue","$vhjCi$useControlledState","isNaN","NaN","inputValue","setInputValue","$vhjCi$useState","$vhjCi$NumberFormatter","format","numberParser","$vhjCi$useMemo","$vhjCi$NumberParser","numberingSystem","getNumberingSystem","formatter","intlOptions","resolvedOptions","$vhjCi$useCallback","clampStep","style","prevValue","$vhjCi$useRef","prevLocale","prevFormatOptions","Object","is","current","parsedValue","parse","parsed","commit","length","undefined","clampedValue","$vhjCi$clamp","$vhjCi$snapValueToStep","safeNextStep","operation","minMax","prev","newValue","$de67e98908f0c6ee$var$handleDecimalOperation","increment","decrement","incrementToMax","decrementToMin","canIncrement","canDecrement","validate","isValidPartialNumber","operator","value2","result","value1Decimal","toString","split","value2Decimal","value1DecimalLength","value2DecimalLength","multiplier","Math","pow","max","round"],"sources":["C:\\Users\\ev3rg\\OneDrive\\Documents\\GitHub\\gt-bigdata-website\\node_modules\\@react-stately\\numberfield\\dist\\packages\\@react-stately\\numberfield\\src\\useNumberFieldState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {clamp, snapValueToStep, useControlledState} from '@react-stately/utils';\nimport {NumberFieldProps} from '@react-types/numberfield';\nimport {NumberFormatter, NumberParser} from '@internationalized/number';\nimport {useCallback, useMemo, useRef, useState} from 'react';\n\nexport interface NumberFieldState {\n  /**\n   * The current text value of the input. Updated as the user types,\n   * and formatted according to `formatOptions` on blur.\n   */\n  inputValue: string,\n  /**\n   * The currently parsed number value, or NaN if a valid number could not be parsed.\n   * Updated based on the `inputValue` as the user types.\n   */\n  numberValue: number,\n  /** The minimum value of the number field. */\n  minValue: number,\n  /** The maximum value of the number field. */\n  maxValue: number,\n  /** Whether the current value can be incremented according to the maximum value and step. */\n  canIncrement: boolean,\n  /** Whether the current value can be decremented according to the minimum value and step. */\n  canDecrement: boolean,\n  /**\n   * Validates a user input string according to the current locale and format options.\n   * Values can be partially entered, and may be valid even if they cannot currently be parsed to a number.\n   * Can be used to implement validation as a user types.\n   */\n  validate(value: string): boolean,\n  /** Sets the current text value of the input. */\n  setInputValue(val: string): void,\n  /**\n   * Commits the current input value. The value is parsed to a number, clamped according\n   * to the minimum and maximum values of the field, and snapped to the nearest step value.\n   * This will fire the `onChange` prop with the new value, and if uncontrolled, update the `numberValue`.\n   * Typically this is called when the field is blurred.\n   */\n  commit(): void,\n  /** Increments the current input value to the next step boundary, and fires `onChange`. */\n  increment(): void,\n  /** Decrements the current input value to the next step boundary, and fires `onChange`. */\n  decrement(): void,\n  /** Sets the current value to the `maxValue` if any, and fires `onChange`. */\n  incrementToMax(): void,\n  /** Sets the current value to the `minValue` if any, and fires `onChange`. */\n  decrementToMin(): void\n}\n\ninterface NumberFieldStateProps extends NumberFieldProps {\n  /**\n   * The locale that should be used for parsing.\n   * @default 'en-US'\n   */\n  locale: string\n}\n\n/**\n * Provides state management for a number field component. Number fields allow users to enter a number,\n * and increment or decrement the value using stepper buttons.\n */\nexport function useNumberFieldState(\n  props: NumberFieldStateProps\n): NumberFieldState {\n  let {\n    minValue,\n    maxValue,\n    step,\n    formatOptions,\n    value,\n    defaultValue,\n    onChange,\n    locale,\n    isDisabled,\n    isReadOnly\n  } = props;\n\n  let [numberValue, setNumberValue] = useControlledState<number>(value, isNaN(defaultValue) ? NaN : defaultValue, onChange);\n  let [inputValue, setInputValue] = useState(() => isNaN(numberValue) ? '' : new NumberFormatter(locale, formatOptions).format(numberValue));\n\n  let numberParser = useMemo(() => new NumberParser(locale, formatOptions), [locale, formatOptions]);\n  let numberingSystem = useMemo(() => numberParser.getNumberingSystem(inputValue), [numberParser, inputValue]);\n  let formatter = useMemo(() => new NumberFormatter(locale, {...formatOptions, numberingSystem}), [locale, formatOptions, numberingSystem]);\n  let intlOptions = useMemo(() => formatter.resolvedOptions(), [formatter]);\n  let format = useCallback((value: number) => isNaN(value) ? '' : formatter.format(value), [formatter]);\n\n  let clampStep = !isNaN(step) ? step : 1;\n  if (intlOptions.style === 'percent' && isNaN(step)) {\n    clampStep = 0.01;\n  }\n\n  // Update the input value when the number value or format options change. This is done\n  // in a useEffect so that the controlled behavior is correct and we only update the\n  // textfield after prop changes.\n  let prevValue = useRef(numberValue);\n  let prevLocale = useRef(locale);\n  let prevFormatOptions = useRef(formatOptions);\n  if (!Object.is(numberValue, prevValue.current) || locale !== prevLocale.current || formatOptions !== prevFormatOptions.current) {\n    setInputValue(format(numberValue));\n    prevValue.current = numberValue;\n    prevLocale.current = locale;\n    prevFormatOptions.current = formatOptions;\n  }\n\n  // Store last parsed value in a ref so it can be used by increment/decrement below\n  let parsedValue = useMemo(() => numberParser.parse(inputValue), [numberParser, inputValue]);\n  let parsed = useRef(0);\n  parsed.current = parsedValue;\n\n  let commit = () => {\n    // Set to empty state if input value is empty\n    if (!inputValue.length) {\n      setNumberValue(NaN);\n      setInputValue(value === undefined ? '' : format(numberValue));\n      return;\n    }\n\n    // if it failed to parse, then reset input to formatted version of current number\n    if (isNaN(parsed.current)) {\n      setInputValue(format(numberValue));\n      return;\n    }\n\n    // Clamp to min and max, round to the nearest step, and round to specified number of digits\n    let clampedValue: number;\n    if (isNaN(step)) {\n      clampedValue = clamp(parsed.current, minValue, maxValue);\n    } else {\n      clampedValue = snapValueToStep(parsed.current, minValue, maxValue, step);\n    }\n\n    clampedValue = numberParser.parse(format(clampedValue));\n    setNumberValue(clampedValue);\n\n    // in a controlled state, the numberValue won't change, so we won't go back to our old input without help\n    setInputValue(format(value === undefined ? clampedValue : numberValue));\n  };\n\n  let safeNextStep = (operation: '+' | '-', minMax: number) => {\n    let prev = parsed.current;\n\n    if (isNaN(prev)) {\n      // if the input is empty, start from the min/max value when incrementing/decrementing,\n      // or zero if there is no min/max value defined.\n      let newValue = isNaN(minMax) ? 0 : minMax;\n      return snapValueToStep(newValue, minValue, maxValue, clampStep);\n    } else {\n      // otherwise, first snap the current value to the nearest step. if it moves in the direction\n      // we're going, use that value, otherwise add the step and snap that value.\n      let newValue = snapValueToStep(prev, minValue, maxValue, clampStep);\n      if ((operation === '+' && newValue > prev) || (operation === '-' && newValue < prev)) {\n        return newValue;\n      }\n\n      return snapValueToStep(\n        handleDecimalOperation(operation, prev, clampStep),\n        minValue,\n        maxValue,\n        clampStep\n      );\n    }\n  };\n\n  let increment = () => {\n    let newValue = safeNextStep('+', minValue);\n\n    // if we've arrived at the same value that was previously in the state, the\n    // input value should be updated to match\n    // ex type 4, press increment, highlight the number in the input, type 4 again, press increment\n    // you'd be at 5, then incrementing to 5 again, so no re-render would happen and 4 would be left in the input\n    if (newValue === numberValue) {\n      setInputValue(format(newValue));\n    }\n\n    setNumberValue(newValue);\n  };\n\n  let decrement = () => {\n    let newValue = safeNextStep('-', maxValue);\n\n    if (newValue === numberValue) {\n      setInputValue(format(newValue));\n    }\n\n    setNumberValue(newValue);\n  };\n\n  let incrementToMax = () => {\n    if (maxValue != null) {\n      setNumberValue(snapValueToStep(maxValue, minValue, maxValue, clampStep));\n    }\n  };\n\n  let decrementToMin = () => {\n    if (minValue != null) {\n      setNumberValue(minValue);\n    }\n  };\n\n  let canIncrement = useMemo(() => (\n    !isDisabled &&\n    !isReadOnly &&\n    (\n      isNaN(parsedValue) ||\n      isNaN(maxValue) ||\n      snapValueToStep(parsedValue, minValue, maxValue, clampStep) > parsedValue ||\n      handleDecimalOperation('+', parsedValue, clampStep) <= maxValue\n    )\n  ), [isDisabled, isReadOnly, minValue, maxValue, clampStep, parsedValue]);\n\n  let canDecrement = useMemo(() => (\n    !isDisabled &&\n    !isReadOnly &&\n    (\n      isNaN(parsedValue) ||\n      isNaN(minValue) ||\n      snapValueToStep(parsedValue, minValue, maxValue, clampStep) < parsedValue ||\n      handleDecimalOperation('-', parsedValue, clampStep) >= minValue\n    )\n  ), [isDisabled, isReadOnly, minValue, maxValue, clampStep, parsedValue]);\n\n  let validate = (value: string) => numberParser.isValidPartialNumber(value, minValue, maxValue);\n\n  return {\n    validate,\n    increment,\n    incrementToMax,\n    decrement,\n    decrementToMin,\n    canIncrement,\n    canDecrement,\n    minValue,\n    maxValue,\n    numberValue: parsedValue,\n    setInputValue,\n    inputValue,\n    commit\n  };\n}\n\nfunction handleDecimalOperation(operator: '-' | '+', value1: number, value2: number): number {\n  let result = operator === '+' ? value1 + value2 : value1 - value2;\n\n  // Check if we have decimals\n  if (value1 % 1 !== 0 || value2 % 1 !== 0) {\n    const value1Decimal = value1.toString().split('.');\n    const value2Decimal = value2.toString().split('.');\n    const value1DecimalLength = (value1Decimal[1] && value1Decimal[1].length) || 0;\n    const value2DecimalLength = (value2Decimal[1] && value2Decimal[1].length) || 0;\n    const multiplier = Math.pow(10, Math.max(value1DecimalLength, value2DecimalLength));\n\n    // Transform the decimals to integers based on the precision\n    value1 = Math.round(value1 * multiplier);\n    value2 = Math.round(value2 * multiplier);\n\n    // Perform the operation on integers values to make sure we don't get a fancy decimal value\n    result = operator === '+' ? value1 + value2 : value1 - value2;\n\n    // Transform the integer result back to decimal\n    result /= multiplier;\n  }\n\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}