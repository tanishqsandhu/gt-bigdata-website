{"ast":null,"code":"import { useGlobalListeners as $axlgK$useGlobalListeners, clamp as $axlgK$clamp, mergeProps as $axlgK$mergeProps, focusWithoutScrolling as $axlgK$focusWithoutScrolling } from \"@react-aria/utils\";\nimport { useRef as $axlgK$useRef, useCallback as $axlgK$useCallback, useEffect as $axlgK$useEffect } from \"react\";\nimport { useMove as $axlgK$useMove, setInteractionModality as $axlgK$setInteractionModality } from \"@react-aria/interactions\";\nimport { useLabel as $axlgK$useLabel } from \"@react-aria/label\";\nimport { useLocale as $axlgK$useLocale } from \"@react-aria/i18n\";\nimport { useFocusable as $axlgK$useFocusable } from \"@react-aria/focus\";\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n\nvar $330dff91662306eb$exports = {};\n$parcel$export($330dff91662306eb$exports, \"useSlider\", () => $330dff91662306eb$export$56b2c08e277f365);\nconst $8983e12064147eaf$export$7a8d2b02c9371cbf = new WeakMap();\n\nfunction $8983e12064147eaf$export$68e648cbec363a18(state, index) {\n  let id = $8983e12064147eaf$export$7a8d2b02c9371cbf.get(state);\n  if (!id) throw new Error('Unknown slider state');\n  return `${id}-${index}`;\n}\n\nfunction $330dff91662306eb$export$56b2c08e277f365(props, state, trackRef) {\n  let {\n    labelProps: labelProps,\n    fieldProps: fieldProps\n  } = $axlgK$useLabel(props);\n  let isVertical = props.orientation === 'vertical';\n\n  var _id; // Attach id of the label to the state so it can be accessed by useSliderThumb.\n\n\n  $8983e12064147eaf$export$7a8d2b02c9371cbf.set(state, (_id = labelProps.id) !== null && _id !== void 0 ? _id : fieldProps.id);\n  let {\n    direction: direction\n  } = $axlgK$useLocale();\n  let {\n    addGlobalListener: addGlobalListener,\n    removeGlobalListener: removeGlobalListener\n  } = $axlgK$useGlobalListeners(); // When the user clicks or drags the track, we want the motion to set and drag the\n  // closest thumb.  Hence we also need to install useMove() on the track element.\n  // Here, we keep track of which index is the \"closest\" to the drag start point.\n  // It is set onMouseDown/onTouchDown; see trackProps below.\n\n  const realTimeTrackDraggingIndex = $axlgK$useRef(null);\n  const stateRef = $axlgK$useRef(null);\n  stateRef.current = state;\n  const reverseX = direction === 'rtl';\n  const currentPosition = $axlgK$useRef(null);\n  const {\n    moveProps: moveProps\n  } = $axlgK$useMove({\n    onMoveStart() {\n      currentPosition.current = null;\n    },\n\n    onMove(_ref) {\n      let {\n        deltaX: deltaX,\n        deltaY: deltaY\n      } = _ref;\n      let size = isVertical ? trackRef.current.offsetHeight : trackRef.current.offsetWidth;\n      if (currentPosition.current == null) currentPosition.current = stateRef.current.getThumbPercent(realTimeTrackDraggingIndex.current) * size;\n      let delta = isVertical ? deltaY : deltaX;\n      if (isVertical || reverseX) delta = -delta;\n      currentPosition.current += delta;\n\n      if (realTimeTrackDraggingIndex.current != null && trackRef.current) {\n        const percent = $axlgK$clamp(currentPosition.current / size, 0, 1);\n        stateRef.current.setThumbPercent(realTimeTrackDraggingIndex.current, percent);\n      }\n    },\n\n    onMoveEnd() {\n      if (realTimeTrackDraggingIndex.current != null) {\n        stateRef.current.setThumbDragging(realTimeTrackDraggingIndex.current, false);\n        realTimeTrackDraggingIndex.current = null;\n      }\n    }\n\n  });\n  let currentPointer = $axlgK$useRef(undefined);\n\n  let onDownTrack = (e, id, clientX, clientY) => {\n    // We only trigger track-dragging if the user clicks on the track itself and nothing is currently being dragged.\n    if (trackRef.current && !props.isDisabled && state.values.every((_, i) => !state.isThumbDragging(i))) {\n      let size = isVertical ? trackRef.current.offsetHeight : trackRef.current.offsetWidth; // Find the closest thumb\n\n      const trackPosition = trackRef.current.getBoundingClientRect()[isVertical ? 'top' : 'left'];\n      const clickPosition = isVertical ? clientY : clientX;\n      const offset = clickPosition - trackPosition;\n      let percent = offset / size;\n      if (direction === 'rtl' || isVertical) percent = 1 - percent;\n      let value = state.getPercentValue(percent); // to find the closet thumb we split the array based on the first thumb position to the \"right/end\" of the click.\n\n      let closestThumb;\n      let split = state.values.findIndex(v => value - v < 0);\n      if (split === 0) closestThumb = split;else if (split === -1) closestThumb = state.values.length - 1;else {\n        let lastLeft = state.values[split - 1];\n        let firstRight = state.values[split]; // Pick the last left/start thumb, unless they are stacked on top of each other, then pick the right/end one\n\n        if (Math.abs(lastLeft - value) < Math.abs(firstRight - value)) closestThumb = split - 1;else closestThumb = split;\n      } // Confirm that the found closest thumb is editable, not disabled, and move it\n\n      if (closestThumb >= 0 && state.isThumbEditable(closestThumb)) {\n        // Don't unfocus anything\n        e.preventDefault();\n        realTimeTrackDraggingIndex.current = closestThumb;\n        state.setFocusedThumb(closestThumb);\n        currentPointer.current = id;\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, true);\n        state.setThumbValue(closestThumb, value);\n        addGlobalListener(window, 'mouseup', onUpTrack, false);\n        addGlobalListener(window, 'touchend', onUpTrack, false);\n        addGlobalListener(window, 'pointerup', onUpTrack, false);\n      } else realTimeTrackDraggingIndex.current = null;\n    }\n  };\n\n  let onUpTrack = e => {\n    var ref;\n\n    var _pointerId;\n\n    let id = (_pointerId = e.pointerId) !== null && _pointerId !== void 0 ? _pointerId : (ref = e.changedTouches) === null || ref === void 0 ? void 0 : ref[0].identifier;\n\n    if (id === currentPointer.current) {\n      if (realTimeTrackDraggingIndex.current != null) {\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, false);\n        realTimeTrackDraggingIndex.current = null;\n      }\n\n      removeGlobalListener(window, 'mouseup', onUpTrack, false);\n      removeGlobalListener(window, 'touchend', onUpTrack, false);\n      removeGlobalListener(window, 'pointerup', onUpTrack, false);\n    }\n  };\n\n  if (labelProps.htmlFor) {\n    // Ideally the `for` attribute should point to the first thumb, but VoiceOver on iOS\n    // causes this to override the `aria-labelledby` on the thumb. This causes the first\n    // thumb to only be announced as the slider label rather than its individual name as well.\n    // See https://bugs.webkit.org/show_bug.cgi?id=172464.\n    delete labelProps.htmlFor;\n\n    labelProps.onClick = () => {\n      var // Safari does not focus <input type=\"range\"> elements when clicking on an associated <label>,\n      // so do it manually. In addition, make sure we show the focus ring.\n      ref;\n      (ref = document.getElementById($8983e12064147eaf$export$68e648cbec363a18(state, 0))) === null || ref === void 0 ? void 0 : ref.focus();\n      $axlgK$setInteractionModality('keyboard');\n    };\n  }\n\n  return {\n    labelProps: labelProps,\n    // The root element of the Slider will have role=\"group\" to group together\n    // all the thumb inputs in the Slider.  The label of the Slider will\n    // be used to label the group.\n    groupProps: {\n      role: 'group',\n      ...fieldProps\n    },\n    trackProps: $axlgK$mergeProps({\n      onMouseDown(e) {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) return;\n        onDownTrack(e, undefined, e.clientX, e.clientY);\n      },\n\n      onPointerDown(e) {\n        if (e.pointerType === 'mouse' && (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey)) return;\n        onDownTrack(e, e.pointerId, e.clientX, e.clientY);\n      },\n\n      onTouchStart(e) {\n        onDownTrack(e, e.changedTouches[0].identifier, e.changedTouches[0].clientX, e.changedTouches[0].clientY);\n      }\n\n    }, moveProps),\n    outputProps: {\n      htmlFor: state.values.map((_, index) => $8983e12064147eaf$export$68e648cbec363a18(state, index)).join(' '),\n      'aria-live': 'off'\n    }\n  };\n}\n\nvar $661f0f6c696c467d$exports = {};\n$parcel$export($661f0f6c696c467d$exports, \"useSliderThumb\", () => $661f0f6c696c467d$export$8d15029008292ae);\n\nfunction $661f0f6c696c467d$export$8d15029008292ae(opts, state) {\n  let {\n    index: index,\n    isRequired: isRequired,\n    isDisabled: isDisabled,\n    validationState: validationState,\n    trackRef: trackRef,\n    inputRef: inputRef\n  } = opts;\n  let isVertical = opts.orientation === 'vertical';\n  let {\n    direction: direction\n  } = $axlgK$useLocale();\n  let {\n    addGlobalListener: addGlobalListener,\n    removeGlobalListener: removeGlobalListener\n  } = $axlgK$useGlobalListeners();\n  let labelId = $8983e12064147eaf$export$7a8d2b02c9371cbf.get(state);\n  var ref1;\n  const {\n    labelProps: labelProps,\n    fieldProps: fieldProps\n  } = $axlgK$useLabel({ ...opts,\n    id: $8983e12064147eaf$export$68e648cbec363a18(state, index),\n    'aria-labelledby': `${labelId} ${(ref1 = opts['aria-labelledby']) !== null && ref1 !== void 0 ? ref1 : ''}`.trim()\n  });\n  const value = state.values[index];\n  const focusInput = $axlgK$useCallback(() => {\n    if (inputRef.current) $axlgK$focusWithoutScrolling(inputRef.current);\n  }, [inputRef]);\n  const isFocused = state.focusedThumb === index;\n  $axlgK$useEffect(() => {\n    if (isFocused) focusInput();\n  }, [isFocused, focusInput]);\n  const stateRef = $axlgK$useRef(null);\n  stateRef.current = state;\n  let reverseX = direction === 'rtl';\n  let currentPosition = $axlgK$useRef(null);\n  let {\n    moveProps: moveProps\n  } = $axlgK$useMove({\n    onMoveStart() {\n      currentPosition.current = null;\n      state.setThumbDragging(index, true);\n    },\n\n    onMove(_ref2) {\n      let {\n        deltaX: deltaX,\n        deltaY: deltaY,\n        pointerType: pointerType\n      } = _ref2;\n      let size = isVertical ? trackRef.current.offsetHeight : trackRef.current.offsetWidth;\n      if (currentPosition.current == null) currentPosition.current = stateRef.current.getThumbPercent(index) * size;\n\n      if (pointerType === 'keyboard') {\n        // (invert left/right according to language direction) + (according to vertical)\n        let delta = ((reverseX ? -deltaX : deltaX) + (isVertical ? -deltaY : -deltaY)) * stateRef.current.step;\n        currentPosition.current += delta * size;\n        stateRef.current.setThumbValue(index, stateRef.current.getThumbValue(index) + delta);\n      } else {\n        let delta = isVertical ? deltaY : deltaX;\n        if (isVertical || reverseX) delta = -delta;\n        currentPosition.current += delta;\n        stateRef.current.setThumbPercent(index, $axlgK$clamp(currentPosition.current / size, 0, 1));\n      }\n    },\n\n    onMoveEnd() {\n      state.setThumbDragging(index, false);\n    }\n\n  }); // Immediately register editability with the state\n\n  state.setThumbEditable(index, !isDisabled);\n  const {\n    focusableProps: focusableProps\n  } = $axlgK$useFocusable($axlgK$mergeProps(opts, {\n    onFocus: () => state.setFocusedThumb(index),\n    onBlur: () => state.setFocusedThumb(undefined)\n  }), inputRef);\n  let currentPointer = $axlgK$useRef(undefined);\n\n  let onDown = id => {\n    focusInput();\n    currentPointer.current = id;\n    state.setThumbDragging(index, true);\n    addGlobalListener(window, 'mouseup', onUp, false);\n    addGlobalListener(window, 'touchend', onUp, false);\n    addGlobalListener(window, 'pointerup', onUp, false);\n  };\n\n  let onUp = e => {\n    var ref;\n\n    var _pointerId;\n\n    let id = (_pointerId = e.pointerId) !== null && _pointerId !== void 0 ? _pointerId : (ref = e.changedTouches) === null || ref === void 0 ? void 0 : ref[0].identifier;\n\n    if (id === currentPointer.current) {\n      focusInput();\n      state.setThumbDragging(index, false);\n      removeGlobalListener(window, 'mouseup', onUp, false);\n      removeGlobalListener(window, 'touchend', onUp, false);\n      removeGlobalListener(window, 'pointerup', onUp, false);\n    }\n  }; // We install mouse handlers for the drag motion on the thumb div, but\n  // not the key handler for moving the thumb with the slider.  Instead,\n  // we focus the range input, and let the browser handle the keyboard\n  // interactions; we then listen to input's onChange to update state.\n\n\n  return {\n    inputProps: $axlgK$mergeProps(focusableProps, fieldProps, {\n      type: 'range',\n      tabIndex: !isDisabled ? 0 : undefined,\n      min: state.getThumbMinValue(index),\n      max: state.getThumbMaxValue(index),\n      step: state.step,\n      value: value,\n      disabled: isDisabled,\n      'aria-orientation': opts.orientation,\n      'aria-valuetext': state.getThumbValueLabel(index),\n      'aria-required': isRequired || undefined,\n      'aria-invalid': validationState === 'invalid' || undefined,\n      'aria-errormessage': opts['aria-errormessage'],\n      onChange: e => {\n        state.setThumbValue(index, parseFloat(e.target.value));\n      }\n    }),\n    thumbProps: !isDisabled ? $axlgK$mergeProps(moveProps, {\n      onMouseDown: e => {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) return;\n        onDown();\n      },\n      onPointerDown: e => {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) return;\n        onDown(e.pointerId);\n      },\n      onTouchStart: e => {\n        onDown(e.changedTouches[0].identifier);\n      }\n    }) : {},\n    labelProps: labelProps\n  };\n}\n\nexport { $330dff91662306eb$export$56b2c08e277f365 as useSlider, $661f0f6c696c467d$export$8d15029008292ae as useSliderThumb };","map":{"version":3,"mappings":"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","names":["$8983e12064147eaf$export$7a8d2b02c9371cbf","WeakMap","$8983e12064147eaf$export$68e648cbec363a18","state","index","id","get","Error","$330dff91662306eb$export$56b2c08e277f365","props","trackRef","labelProps","fieldProps","$axlgK$useLabel","isVertical","orientation","_id","set","direction","$axlgK$useLocale","addGlobalListener","removeGlobalListener","$axlgK$useGlobalListeners","realTimeTrackDraggingIndex","$axlgK$useRef","stateRef","current","reverseX","currentPosition","moveProps","$axlgK$useMove","onMoveStart","onMove","deltaX","deltaY","size","offsetHeight","offsetWidth","getThumbPercent","delta","percent","$axlgK$clamp","setThumbPercent","onMoveEnd","setThumbDragging","currentPointer","undefined","onDownTrack","e","clientX","clientY","isDisabled","values","every","_","i","isThumbDragging","trackPosition","getBoundingClientRect","clickPosition","offset","value","getPercentValue","closestThumb","split","findIndex","v","length","lastLeft","firstRight","Math","abs","isThumbEditable","preventDefault","setFocusedThumb","setThumbValue","window","onUpTrack","ref","_pointerId","pointerId","changedTouches","identifier","htmlFor","onClick","document","getElementById","focus","$axlgK$setInteractionModality","groupProps","role","trackProps","$axlgK$mergeProps","onMouseDown","button","altKey","ctrlKey","metaKey","onPointerDown","pointerType","onTouchStart","outputProps","map","join","$661f0f6c696c467d$export$8d15029008292ae","opts","isRequired","validationState","inputRef","labelId","ref1","trim","focusInput","$axlgK$useCallback","$axlgK$focusWithoutScrolling","isFocused","focusedThumb","$axlgK$useEffect","step","getThumbValue","setThumbEditable","focusableProps","$axlgK$useFocusable","onFocus","onBlur","onDown","onUp","inputProps","type","tabIndex","min","getThumbMinValue","max","getThumbMaxValue","disabled","getThumbValueLabel","onChange","parseFloat","target","thumbProps"],"sources":["/Users/asattiraju/Desktop/gt-bigdata-website/node_modules/@react-aria/slider/dist/packages/@react-aria/slider/src/utils.ts","/Users/asattiraju/Desktop/gt-bigdata-website/node_modules/@react-aria/slider/dist/packages/@react-aria/slider/src/useSlider.ts","/Users/asattiraju/Desktop/gt-bigdata-website/node_modules/@react-aria/slider/dist/packages/@react-aria/slider/src/useSliderThumb.ts"],"sourcesContent":["import {SliderState} from '@react-stately/slider';\n\nexport const sliderIds = new WeakMap<SliderState, string>();\n\nexport function getSliderThumbId(state: SliderState, index: number) {\n  let id = sliderIds.get(state);\n  if (!id) {\n    throw new Error('Unknown slider state');\n  }\n\n  return `${id}-${index}`;\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaSliderProps} from '@react-types/slider';\nimport {clamp, mergeProps, useGlobalListeners} from '@react-aria/utils';\nimport {getSliderThumbId, sliderIds} from './utils';\nimport React, {HTMLAttributes, LabelHTMLAttributes, OutputHTMLAttributes, RefObject, useRef} from 'react';\nimport {setInteractionModality, useMove} from '@react-aria/interactions';\nimport {SliderState} from '@react-stately/slider';\nimport {useLabel} from '@react-aria/label';\nimport {useLocale} from '@react-aria/i18n';\n\ninterface SliderAria {\n  /** Props for the label element. */\n  labelProps: LabelHTMLAttributes<HTMLLabelElement>,\n\n  /** Props for the root element of the slider component; groups slider inputs. */\n  groupProps: HTMLAttributes<HTMLElement>,\n\n  /** Props for the track element. */\n  trackProps: HTMLAttributes<HTMLElement>,\n\n  /** Props for the output element, displaying the value of the slider thumbs. */\n  outputProps: OutputHTMLAttributes<HTMLOutputElement>\n}\n\n/**\n * Provides the behavior and accessibility implementation for a slider component representing one or more values.\n *\n * @param props Props for the slider.\n * @param state State for the slider, as returned by `useSliderState`.\n * @param trackRef Ref for the \"track\" element.  The width of this element provides the \"length\"\n * of the track -- the span of one dimensional space that the slider thumb can be.  It also\n * accepts click and drag motions, so that the closest thumb will follow clicks and drags on\n * the track.\n */\nexport function useSlider(\n  props: AriaSliderProps,\n  state: SliderState,\n  trackRef: RefObject<HTMLElement>\n): SliderAria {\n  let {labelProps, fieldProps} = useLabel(props);\n\n  let isVertical = props.orientation === 'vertical';\n\n  // Attach id of the label to the state so it can be accessed by useSliderThumb.\n  sliderIds.set(state, labelProps.id ?? fieldProps.id);\n\n  let {direction} = useLocale();\n\n  let {addGlobalListener, removeGlobalListener} = useGlobalListeners();\n\n  // When the user clicks or drags the track, we want the motion to set and drag the\n  // closest thumb.  Hence we also need to install useMove() on the track element.\n  // Here, we keep track of which index is the \"closest\" to the drag start point.\n  // It is set onMouseDown/onTouchDown; see trackProps below.\n  const realTimeTrackDraggingIndex = useRef<number | null>(null);\n\n  const stateRef = useRef<SliderState>(null);\n  stateRef.current = state;\n  const reverseX = direction === 'rtl';\n  const currentPosition = useRef<number>(null);\n  const {moveProps} = useMove({\n    onMoveStart() {\n      currentPosition.current = null;\n    },\n    onMove({deltaX, deltaY}) {\n      let size = isVertical ? trackRef.current.offsetHeight : trackRef.current.offsetWidth;\n\n      if (currentPosition.current == null) {\n        currentPosition.current = stateRef.current.getThumbPercent(realTimeTrackDraggingIndex.current) * size;\n      }\n\n      let delta = isVertical ? deltaY : deltaX;\n      if (isVertical || reverseX) {\n        delta = -delta;\n      }\n\n      currentPosition.current += delta;\n\n      if (realTimeTrackDraggingIndex.current != null && trackRef.current) {\n        const percent = clamp(currentPosition.current / size, 0, 1);\n        stateRef.current.setThumbPercent(realTimeTrackDraggingIndex.current, percent);\n      }\n    },\n    onMoveEnd() {\n      if (realTimeTrackDraggingIndex.current != null) {\n        stateRef.current.setThumbDragging(realTimeTrackDraggingIndex.current, false);\n        realTimeTrackDraggingIndex.current = null;\n      }\n    }\n  });\n\n  let currentPointer = useRef<number | null | undefined>(undefined);\n  let onDownTrack = (e: React.UIEvent, id: number, clientX: number, clientY: number) => {\n    // We only trigger track-dragging if the user clicks on the track itself and nothing is currently being dragged.\n    if (trackRef.current && !props.isDisabled && state.values.every((_, i) => !state.isThumbDragging(i))) {\n      let size = isVertical ? trackRef.current.offsetHeight : trackRef.current.offsetWidth;\n      // Find the closest thumb\n      const trackPosition = trackRef.current.getBoundingClientRect()[isVertical ? 'top' : 'left'];\n      const clickPosition = isVertical ? clientY : clientX;\n      const offset = clickPosition - trackPosition;\n      let percent = offset / size;\n      if (direction === 'rtl' || isVertical) {\n        percent = 1 - percent;\n      }\n      let value = state.getPercentValue(percent);\n\n      // to find the closet thumb we split the array based on the first thumb position to the \"right/end\" of the click.\n      let closestThumb;\n      let split = state.values.findIndex(v => value - v < 0);\n      if (split === 0) { // If the index is zero then the closetThumb is the first one\n        closestThumb = split;\n      } else if (split === -1) { // If no index is found they've clicked past all the thumbs\n        closestThumb = state.values.length - 1;\n      } else {\n        let lastLeft = state.values[split - 1];\n        let firstRight = state.values[split];\n        // Pick the last left/start thumb, unless they are stacked on top of each other, then pick the right/end one\n        if (Math.abs(lastLeft - value) < Math.abs(firstRight - value)) {\n          closestThumb = split - 1;\n        } else {\n          closestThumb = split;\n        }\n      }\n\n      // Confirm that the found closest thumb is editable, not disabled, and move it\n      if (closestThumb >= 0 && state.isThumbEditable(closestThumb)) {\n        // Don't unfocus anything\n        e.preventDefault();\n\n        realTimeTrackDraggingIndex.current = closestThumb;\n        state.setFocusedThumb(closestThumb);\n        currentPointer.current = id;\n\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, true);\n        state.setThumbValue(closestThumb, value);\n\n        addGlobalListener(window, 'mouseup', onUpTrack, false);\n        addGlobalListener(window, 'touchend', onUpTrack, false);\n        addGlobalListener(window, 'pointerup', onUpTrack, false);\n      } else {\n        realTimeTrackDraggingIndex.current = null;\n      }\n    }\n  };\n\n  let onUpTrack = (e) => {\n    let id = e.pointerId ?? e.changedTouches?.[0].identifier;\n    if (id === currentPointer.current) {\n      if (realTimeTrackDraggingIndex.current != null) {\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, false);\n        realTimeTrackDraggingIndex.current = null;\n      }\n\n      removeGlobalListener(window, 'mouseup', onUpTrack, false);\n      removeGlobalListener(window, 'touchend', onUpTrack, false);\n      removeGlobalListener(window, 'pointerup', onUpTrack, false);\n    }\n  };\n\n  if (labelProps.htmlFor) {\n    // Ideally the `for` attribute should point to the first thumb, but VoiceOver on iOS\n    // causes this to override the `aria-labelledby` on the thumb. This causes the first\n    // thumb to only be announced as the slider label rather than its individual name as well.\n    // See https://bugs.webkit.org/show_bug.cgi?id=172464.\n    delete labelProps.htmlFor;\n    labelProps.onClick = () => {\n      // Safari does not focus <input type=\"range\"> elements when clicking on an associated <label>,\n      // so do it manually. In addition, make sure we show the focus ring.\n      document.getElementById(getSliderThumbId(state, 0))?.focus();\n      setInteractionModality('keyboard');\n    };\n  }\n\n  return {\n    labelProps,\n    // The root element of the Slider will have role=\"group\" to group together\n    // all the thumb inputs in the Slider.  The label of the Slider will\n    // be used to label the group.\n    groupProps: {\n      role: 'group',\n      ...fieldProps\n    },\n    trackProps: mergeProps({\n      onMouseDown(e: React.MouseEvent<HTMLElement>) {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n          return;\n        }\n        onDownTrack(e, undefined, e.clientX, e.clientY);\n      },\n      onPointerDown(e: React.PointerEvent<HTMLElement>) {\n        if (e.pointerType === 'mouse' && (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey)) {\n          return;\n        }\n        onDownTrack(e, e.pointerId, e.clientX, e.clientY);\n      },\n      onTouchStart(e: React.TouchEvent<HTMLElement>) { onDownTrack(e, e.changedTouches[0].identifier, e.changedTouches[0].clientX, e.changedTouches[0].clientY); }\n    }, moveProps),\n    outputProps: {\n      htmlFor: state.values.map((_, index) => getSliderThumbId(state, index)).join(' '),\n      'aria-live': 'off'\n    }\n  };\n}\n","import {AriaSliderThumbProps} from '@react-types/slider';\nimport {clamp, focusWithoutScrolling, mergeProps, useGlobalListeners} from '@react-aria/utils';\nimport {getSliderThumbId, sliderIds} from './utils';\nimport React, {ChangeEvent, HTMLAttributes, InputHTMLAttributes, LabelHTMLAttributes, RefObject, useCallback, useEffect, useRef} from 'react';\nimport {SliderState} from '@react-stately/slider';\nimport {useFocusable} from '@react-aria/focus';\nimport {useLabel} from '@react-aria/label';\nimport {useLocale} from '@react-aria/i18n';\nimport {useMove} from '@react-aria/interactions';\n\ninterface SliderThumbAria {\n  /** Props for the root thumb element; handles the dragging motion. */\n  thumbProps: HTMLAttributes<HTMLElement>,\n\n  /** Props for the visually hidden range input element. */\n  inputProps: InputHTMLAttributes<HTMLInputElement>,\n\n  /** Props for the label element for this thumb (optional). */\n  labelProps: LabelHTMLAttributes<HTMLLabelElement>\n}\n\ninterface SliderThumbOptions extends AriaSliderThumbProps {\n  /** A ref to the track element. */\n  trackRef: RefObject<HTMLElement>,\n  /** A ref to the thumb input element. */\n  inputRef: RefObject<HTMLInputElement>\n}\n\n/**\n * Provides behavior and accessibility for a thumb of a slider component.\n *\n * @param opts Options for this Slider thumb.\n * @param state Slider state, created via `useSliderState`.\n */\nexport function useSliderThumb(\n  opts: SliderThumbOptions,\n  state: SliderState\n): SliderThumbAria {\n  let {\n    index,\n    isRequired,\n    isDisabled,\n    validationState,\n    trackRef,\n    inputRef\n  } = opts;\n\n  let isVertical = opts.orientation === 'vertical';\n\n  let {direction} = useLocale();\n  let {addGlobalListener, removeGlobalListener} = useGlobalListeners();\n\n  let labelId = sliderIds.get(state);\n  const {labelProps, fieldProps} = useLabel({\n    ...opts,\n    id: getSliderThumbId(state, index),\n    'aria-labelledby': `${labelId} ${opts['aria-labelledby'] ?? ''}`.trim()\n  });\n\n  const value = state.values[index];\n\n  const focusInput = useCallback(() => {\n    if (inputRef.current) {\n      focusWithoutScrolling(inputRef.current);\n    }\n  }, [inputRef]);\n\n  const isFocused = state.focusedThumb === index;\n\n  useEffect(() => {\n    if (isFocused) {\n      focusInput();\n    }\n  }, [isFocused, focusInput]);\n\n  const stateRef = useRef<SliderState>(null);\n  stateRef.current = state;\n  let reverseX = direction === 'rtl';\n  let currentPosition = useRef<number>(null);\n  let {moveProps} = useMove({\n    onMoveStart() {\n      currentPosition.current = null;\n      state.setThumbDragging(index, true);\n    },\n    onMove({deltaX, deltaY, pointerType}) {\n      let size = isVertical ? trackRef.current.offsetHeight : trackRef.current.offsetWidth;\n\n      if (currentPosition.current == null) {\n        currentPosition.current = stateRef.current.getThumbPercent(index) * size;\n      }\n      if (pointerType === 'keyboard') {\n        // (invert left/right according to language direction) + (according to vertical)\n        let delta = ((reverseX ? -deltaX : deltaX) + (isVertical ? -deltaY : -deltaY)) * stateRef.current.step;\n        currentPosition.current += delta * size;\n        stateRef.current.setThumbValue(index, stateRef.current.getThumbValue(index) + delta);\n      } else {\n        let delta = isVertical ? deltaY : deltaX;\n        if (isVertical || reverseX) {\n          delta = -delta;\n        }\n\n        currentPosition.current += delta;\n        stateRef.current.setThumbPercent(index, clamp(currentPosition.current / size, 0, 1));\n      }\n    },\n    onMoveEnd() {\n      state.setThumbDragging(index, false);\n    }\n  });\n\n  // Immediately register editability with the state\n  state.setThumbEditable(index, !isDisabled);\n\n  const {focusableProps} = useFocusable(\n    mergeProps(opts, {\n      onFocus: () => state.setFocusedThumb(index),\n      onBlur: () => state.setFocusedThumb(undefined)\n    }),\n    inputRef\n  );\n\n  let currentPointer = useRef<number | undefined>(undefined);\n  let onDown = (id?: number) => {\n    focusInput();\n    currentPointer.current = id;\n    state.setThumbDragging(index, true);\n\n    addGlobalListener(window, 'mouseup', onUp, false);\n    addGlobalListener(window, 'touchend', onUp, false);\n    addGlobalListener(window, 'pointerup', onUp, false);\n\n  };\n\n  let onUp = (e) => {\n    let id = e.pointerId ?? e.changedTouches?.[0].identifier;\n    if (id === currentPointer.current) {\n      focusInput();\n      state.setThumbDragging(index, false);\n      removeGlobalListener(window, 'mouseup', onUp, false);\n      removeGlobalListener(window, 'touchend', onUp, false);\n      removeGlobalListener(window, 'pointerup', onUp, false);\n    }\n  };\n\n  // We install mouse handlers for the drag motion on the thumb div, but\n  // not the key handler for moving the thumb with the slider.  Instead,\n  // we focus the range input, and let the browser handle the keyboard\n  // interactions; we then listen to input's onChange to update state.\n  return {\n    inputProps: mergeProps(focusableProps, fieldProps, {\n      type: 'range',\n      tabIndex: !isDisabled ? 0 : undefined,\n      min: state.getThumbMinValue(index),\n      max: state.getThumbMaxValue(index),\n      step: state.step,\n      value: value,\n      disabled: isDisabled,\n      'aria-orientation': opts.orientation,\n      'aria-valuetext': state.getThumbValueLabel(index),\n      'aria-required': isRequired || undefined,\n      'aria-invalid': validationState === 'invalid' || undefined,\n      'aria-errormessage': opts['aria-errormessage'],\n      onChange: (e: ChangeEvent<HTMLInputElement>) => {\n        state.setThumbValue(index, parseFloat(e.target.value));\n      }\n    }),\n    thumbProps: !isDisabled ? mergeProps(\n      moveProps,\n      {\n        onMouseDown: (e: React.MouseEvent<HTMLElement>) => {\n          if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n            return;\n          }\n          onDown();\n        },\n        onPointerDown: (e: React.PointerEvent<HTMLElement>) => {\n          if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n            return;\n          }\n          onDown(e.pointerId);\n        },\n        onTouchStart: (e: React.TouchEvent<HTMLElement>) => {onDown(e.changedTouches[0].identifier);}\n      }\n    ) : {},\n    labelProps\n  };\n}\n"]},"metadata":{},"sourceType":"module"}