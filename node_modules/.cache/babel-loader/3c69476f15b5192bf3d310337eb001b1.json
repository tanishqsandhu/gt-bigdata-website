{"ast":null,"code":"import { snapValueToStep as $aTwux$snapValueToStep, clamp as $aTwux$clamp } from \"@react-aria/utils\";\nimport { useControlledState as $aTwux$useControlledState } from \"@react-stately/utils\";\nimport { useMemo as $aTwux$useMemo, useState as $aTwux$useState, useRef as $aTwux$useRef } from \"react\";\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n\nvar $28f99e3e86e6ec45$exports = {};\n$parcel$export($28f99e3e86e6ec45$exports, \"useSliderState\", () => $28f99e3e86e6ec45$export$e5fda3247f5d67f9);\nconst $28f99e3e86e6ec45$var$DEFAULT_MIN_VALUE = 0;\nconst $28f99e3e86e6ec45$var$DEFAULT_MAX_VALUE = 100;\nconst $28f99e3e86e6ec45$var$DEFAULT_STEP_VALUE = 1;\n\nfunction $28f99e3e86e6ec45$export$e5fda3247f5d67f9(props) {\n  const {\n    isDisabled: isDisabled,\n    minValue = $28f99e3e86e6ec45$var$DEFAULT_MIN_VALUE,\n    maxValue = $28f99e3e86e6ec45$var$DEFAULT_MAX_VALUE,\n    numberFormatter: formatter,\n    step = $28f99e3e86e6ec45$var$DEFAULT_STEP_VALUE\n  } = props; // Page step should be at least equal to step and always a multiple of the step.\n\n  let pageSize = $aTwux$useMemo(() => {\n    let calcPageSize = (maxValue - minValue) / 10;\n    calcPageSize = $aTwux$snapValueToStep(calcPageSize, 0, calcPageSize + step, step);\n    return Math.max(calcPageSize, step);\n  }, [step, maxValue, minValue]);\n\n  var _defaultValue;\n\n  const [values, setValues] = $aTwux$useControlledState(props.value, (_defaultValue = props.defaultValue) !== null && _defaultValue !== void 0 ? _defaultValue : [minValue], props.onChange);\n  const [isDraggings, setDraggings] = $aTwux$useState(new Array(values.length).fill(false));\n  const isEditablesRef = $aTwux$useRef(new Array(values.length).fill(true));\n  const [focusedIndex, setFocusedIndex] = $aTwux$useState(undefined);\n  const valuesRef = $aTwux$useRef(null);\n  valuesRef.current = values;\n  const isDraggingsRef = $aTwux$useRef(null);\n  isDraggingsRef.current = isDraggings;\n\n  function getValuePercent(value) {\n    return (value - minValue) / (maxValue - minValue);\n  }\n\n  function getThumbMinValue(index) {\n    return index === 0 ? minValue : values[index - 1];\n  }\n\n  function getThumbMaxValue(index) {\n    return index === values.length - 1 ? maxValue : values[index + 1];\n  }\n\n  function isThumbEditable(index) {\n    return isEditablesRef.current[index];\n  }\n\n  function setThumbEditable(index, editable) {\n    isEditablesRef.current[index] = editable;\n  }\n\n  function updateValue(index, value) {\n    if (isDisabled || !isThumbEditable(index)) return;\n    const thisMin = getThumbMinValue(index);\n    const thisMax = getThumbMaxValue(index); // Round value to multiple of step, clamp value between min and max\n\n    value = $aTwux$snapValueToStep(value, thisMin, thisMax, step);\n    valuesRef.current = $28f99e3e86e6ec45$var$replaceIndex(valuesRef.current, index, value);\n    setValues(valuesRef.current);\n  }\n\n  function updateDragging(index, dragging) {\n    if (isDisabled || !isThumbEditable(index)) return;\n    const wasDragging = isDraggingsRef.current[index];\n    isDraggingsRef.current = $28f99e3e86e6ec45$var$replaceIndex(isDraggingsRef.current, index, dragging);\n    setDraggings(isDraggingsRef.current); // Call onChangeEnd if no handles are dragging.\n\n    if (props.onChangeEnd && wasDragging && !isDraggingsRef.current.some(Boolean)) props.onChangeEnd(valuesRef.current);\n  }\n\n  function getFormattedValue(value) {\n    return formatter.format(value);\n  }\n\n  function setThumbPercent(index, percent) {\n    updateValue(index, getPercentValue(percent));\n  }\n\n  function getRoundedValue(value) {\n    return Math.round((value - minValue) / step) * step + minValue;\n  }\n\n  function getPercentValue(percent) {\n    const val = percent * (maxValue - minValue) + minValue;\n    return $aTwux$clamp(getRoundedValue(val), minValue, maxValue);\n  }\n\n  function incrementThumb(index) {\n    let stepSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let s = Math.max(stepSize, step);\n    updateValue(index, $aTwux$snapValueToStep(values[index] + s, minValue, maxValue, step));\n  }\n\n  function decrementThumb(index) {\n    let stepSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let s = Math.max(stepSize, step);\n    updateValue(index, $aTwux$snapValueToStep(values[index] - s, minValue, maxValue, step));\n  }\n\n  return {\n    values: values,\n    getThumbValue: index => values[index],\n    setThumbValue: updateValue,\n    setThumbPercent: setThumbPercent,\n    isThumbDragging: index => isDraggings[index],\n    setThumbDragging: updateDragging,\n    focusedThumb: focusedIndex,\n    setFocusedThumb: setFocusedIndex,\n    getThumbPercent: index => getValuePercent(values[index]),\n    getValuePercent: getValuePercent,\n    getThumbValueLabel: index => getFormattedValue(values[index]),\n    getFormattedValue: getFormattedValue,\n    getThumbMinValue: getThumbMinValue,\n    getThumbMaxValue: getThumbMaxValue,\n    getPercentValue: getPercentValue,\n    isThumbEditable: isThumbEditable,\n    setThumbEditable: setThumbEditable,\n    incrementThumb: incrementThumb,\n    decrementThumb: decrementThumb,\n    step: step,\n    pageSize: pageSize\n  };\n}\n\nfunction $28f99e3e86e6ec45$var$replaceIndex(array, index, value) {\n  if (array[index] === value) return array;\n  return [...array.slice(0, index), value, ...array.slice(index + 1)];\n}\n\nexport { $28f99e3e86e6ec45$export$e5fda3247f5d67f9 as useSliderState };","map":{"version":3,"mappings":"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","names":["$28f99e3e86e6ec45$var$DEFAULT_MIN_VALUE","$28f99e3e86e6ec45$var$DEFAULT_MAX_VALUE","$28f99e3e86e6ec45$var$DEFAULT_STEP_VALUE","$28f99e3e86e6ec45$export$e5fda3247f5d67f9","props","isDisabled","minValue","maxValue","numberFormatter","formatter","step","pageSize","$aTwux$useMemo","calcPageSize","$aTwux$snapValueToStep","Math","max","_defaultValue","values","setValues","$aTwux$useControlledState","value","defaultValue","onChange","isDraggings","setDraggings","$aTwux$useState","Array","length","fill","isEditablesRef","$aTwux$useRef","focusedIndex","setFocusedIndex","undefined","valuesRef","current","isDraggingsRef","getValuePercent","getThumbMinValue","index","getThumbMaxValue","isThumbEditable","setThumbEditable","editable","updateValue","thisMin","thisMax","$28f99e3e86e6ec45$var$replaceIndex","updateDragging","dragging","wasDragging","onChangeEnd","some","Boolean","getFormattedValue","format","setThumbPercent","percent","getPercentValue","getRoundedValue","round","val","$aTwux$clamp","incrementThumb","stepSize","s","decrementThumb","getThumbValue","setThumbValue","isThumbDragging","setThumbDragging","focusedThumb","setFocusedThumb","getThumbPercent","getThumbValueLabel","array","slice"],"sources":["C:\\Users\\ev3rg\\OneDrive\\Documents\\GitHub\\gt-bigdata-website\\node_modules\\@react-stately\\slider\\dist\\packages\\@react-stately\\slider\\src\\useSliderState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {clamp, snapValueToStep} from '@react-aria/utils';\nimport {SliderProps} from '@react-types/slider';\nimport {useControlledState} from '@react-stately/utils';\nimport {useMemo, useRef, useState} from 'react';\n\nexport interface SliderState {\n  /**\n   * Values managed by the slider by thumb index.\n   */\n  readonly values: number[],\n  /**\n   * Get the value for the specified thumb.\n   * @param index\n   */\n  getThumbValue(index: number): number,\n\n  /**\n   * Sets the value for the specified thumb.\n   * The actual value set will be clamped and rounded according to min/max/step.\n   * @param index\n   * @param value\n   */\n  setThumbValue(index: number, value: number): void,\n\n  /**\n   * Sets value for the specified thumb by percent offset (between 0 and 1).\n   * @param index\n   * @param percent\n   */\n  setThumbPercent(index: number, percent: number): void,\n\n  /**\n   * Whether the specific thumb is being dragged.\n   * @param index\n   */\n  isThumbDragging(index: number): boolean,\n  /**\n   * Set is dragging on the specified thumb.\n   * @param index\n   * @param dragging\n   */\n  setThumbDragging(index: number, dragging: boolean): void,\n\n  /**\n   * Currently-focused thumb index.\n   */\n  readonly focusedThumb: number | undefined,\n  /**\n   * Set focused true on specified thumb. This will remove focus from\n   * any thumb that had it before.\n   * @param index\n   */\n  setFocusedThumb(index: number | undefined): void,\n\n  /**\n   * Returns the specified thumb's value as a percentage from 0 to 1.\n   * @param index\n   */\n  getThumbPercent(index: number): number,\n\n  /**\n   * Returns the value as a percent between the min and max of the slider.\n   * @param index\n   */\n  getValuePercent(value: number): number,\n\n  /**\n   * Returns the string label for the specified thumb's value, per props.formatOptions.\n   * @param index\n   */\n  getThumbValueLabel(index: number): string,\n\n  /**\n   * Returns the string label for the value, per props.formatOptions.\n   * @param index\n   */\n  getFormattedValue(value: number): string,\n\n  /**\n   * Returns the min allowed value for the specified thumb.\n   * @param index\n   */\n  getThumbMinValue(index: number): number,\n\n  /**\n   * Returns the max allowed value for the specified thumb.\n   * @param index\n   */\n  getThumbMaxValue(index: number): number,\n\n  /**\n   * Converts a percent along track (between 0 and 1) to the corresponding value.\n   * @param percent\n   */\n  getPercentValue(percent: number): number,\n\n  /**\n   * Returns if the specified thumb is editable.\n   * @param index\n   */\n  isThumbEditable(index: number): boolean,\n\n  /**\n   * Set the specified thumb's editable state.\n   * @param index\n   * @param editable\n   */\n  setThumbEditable(index: number, editable: boolean): void,\n\n  /**\n   * Increments the value of the thumb by the step or page amount.\n   */\n  incrementThumb(index: number, stepSize?: number): void,\n  /**\n   * Decrements the value of the thumb by the step or page amount.\n   */\n  decrementThumb(index: number, stepSize?: number): void,\n\n  /**\n   * The step amount for the slider.\n   */\n  readonly step: number,\n\n  /**\n   * The page size for the slider, used to do a bigger step.\n   */\n  readonly pageSize: number\n}\n\nconst DEFAULT_MIN_VALUE = 0;\nconst DEFAULT_MAX_VALUE = 100;\nconst DEFAULT_STEP_VALUE = 1;\n\ninterface SliderStateOptions extends SliderProps {\n  numberFormatter: Intl.NumberFormat\n}\n\n/**\n * Provides state management for a slider component. Stores values for all thumbs,\n * formats values for localization, and provides methods to update the position\n * of any thumbs.\n * @param props\n */\nexport function useSliderState(props: SliderStateOptions): SliderState {\n  const {\n    isDisabled,\n    minValue = DEFAULT_MIN_VALUE,\n    maxValue = DEFAULT_MAX_VALUE,\n    numberFormatter: formatter,\n    step = DEFAULT_STEP_VALUE\n  } = props;\n\n  // Page step should be at least equal to step and always a multiple of the step.\n  let pageSize = useMemo(() => {\n    let calcPageSize = (maxValue - minValue) / 10;\n    calcPageSize = snapValueToStep(calcPageSize, 0, calcPageSize + step, step);\n    return Math.max(calcPageSize, step);\n  }, [step, maxValue, minValue]);\n\n  const [values, setValues] = useControlledState<number[]>(\n    props.value as any,\n    props.defaultValue ?? [minValue] as any,\n    props.onChange as any\n  );\n  const [isDraggings, setDraggings] = useState<boolean[]>(new Array(values.length).fill(false));\n  const isEditablesRef = useRef<boolean[]>(new Array(values.length).fill(true));\n  const [focusedIndex, setFocusedIndex] = useState<number | undefined>(undefined);\n\n  const valuesRef = useRef<number[]>(null);\n  valuesRef.current = values;\n  const isDraggingsRef = useRef<boolean[]>(null);\n  isDraggingsRef.current = isDraggings;\n\n  function getValuePercent(value: number) {\n    return (value - minValue) / (maxValue - minValue);\n  }\n\n  function getThumbMinValue(index: number) {\n    return index === 0 ? minValue : values[index - 1];\n  }\n  function getThumbMaxValue(index: number) {\n    return index === values.length - 1 ? maxValue : values[index + 1];\n  }\n\n  function isThumbEditable(index: number) {\n    return isEditablesRef.current[index];\n  }\n\n  function setThumbEditable(index: number, editable: boolean) {\n    isEditablesRef.current[index] = editable;\n  }\n\n  function updateValue(index: number, value: number) {\n    if (isDisabled || !isThumbEditable(index)) {\n      return;\n    }\n    const thisMin = getThumbMinValue(index);\n    const thisMax = getThumbMaxValue(index);\n\n    // Round value to multiple of step, clamp value between min and max\n    value = snapValueToStep(value, thisMin, thisMax, step);\n    valuesRef.current = replaceIndex(valuesRef.current, index, value);\n    setValues(valuesRef.current);\n  }\n\n  function updateDragging(index: number, dragging: boolean) {\n    if (isDisabled || !isThumbEditable(index)) {\n      return;\n    }\n\n    const wasDragging = isDraggingsRef.current[index];\n    isDraggingsRef.current = replaceIndex(isDraggingsRef.current, index, dragging);\n    setDraggings(isDraggingsRef.current);\n\n    // Call onChangeEnd if no handles are dragging.\n    if (props.onChangeEnd && wasDragging && !isDraggingsRef.current.some(Boolean)) {\n      props.onChangeEnd(valuesRef.current);\n    }\n  }\n\n  function getFormattedValue(value: number) {\n    return formatter.format(value);\n  }\n\n  function setThumbPercent(index: number, percent: number) {\n    updateValue(index, getPercentValue(percent));\n  }\n\n  function getRoundedValue(value: number) {\n    return Math.round((value - minValue) / step) * step + minValue;\n  }\n\n  function getPercentValue(percent: number) {\n    const val = percent * (maxValue - minValue) + minValue;\n    return clamp(getRoundedValue(val), minValue, maxValue);\n  }\n\n  function incrementThumb(index: number, stepSize: number = 1) {\n    let s = Math.max(stepSize, step);\n    updateValue(index, snapValueToStep(values[index] + s, minValue, maxValue, step));\n  }\n\n  function decrementThumb(index: number, stepSize: number = 1) {\n    let s = Math.max(stepSize, step);\n    updateValue(index, snapValueToStep(values[index] - s, minValue, maxValue, step));\n  }\n\n  return {\n    values: values,\n    getThumbValue: (index: number) => values[index],\n    setThumbValue: updateValue,\n    setThumbPercent,\n    isThumbDragging: (index: number) => isDraggings[index],\n    setThumbDragging: updateDragging,\n    focusedThumb: focusedIndex,\n    setFocusedThumb: setFocusedIndex,\n    getThumbPercent: (index: number) => getValuePercent(values[index]),\n    getValuePercent,\n    getThumbValueLabel: (index: number) => getFormattedValue(values[index]),\n    getFormattedValue,\n    getThumbMinValue,\n    getThumbMaxValue,\n    getPercentValue,\n    isThumbEditable,\n    setThumbEditable,\n    incrementThumb,\n    decrementThumb,\n    step,\n    pageSize\n  };\n}\n\nfunction replaceIndex<T>(array: T[], index: number, value: T) {\n  if (array[index] === value) {\n    return array;\n  }\n\n  return [...array.slice(0, index), value, ...array.slice(index + 1)];\n}\n"]},"metadata":{},"sourceType":"module"}