{"ast":null,"code":"import { useRef as $Qsto2$useRef, useState as $Qsto2$useState, useMemo as $Qsto2$useMemo } from \"react\";\nimport { useControlledState as $Qsto2$useControlledState } from \"@react-stately/utils\";\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n\nvar $7af3f5b51489e0b5$exports = {};\n$parcel$export($7af3f5b51489e0b5$exports, \"useMultipleSelectionState\", () => $7af3f5b51489e0b5$export$253fe78d46329472);\n\nclass $e40ea825a81a3709$export$52baac22726c72bf extends Set {\n  constructor(keys, anchorKey, currentKey) {\n    super(keys);\n\n    if (keys instanceof $e40ea825a81a3709$export$52baac22726c72bf) {\n      this.anchorKey = anchorKey || keys.anchorKey;\n      this.currentKey = currentKey || keys.currentKey;\n    } else {\n      this.anchorKey = anchorKey;\n      this.currentKey = currentKey;\n    }\n  }\n\n}\n\nfunction $7af3f5b51489e0b5$var$equalSets(setA, setB) {\n  if (setA.size !== setB.size) return false;\n\n  for (let item of setA) {\n    if (!setB.has(item)) return false;\n  }\n\n  return true;\n}\n\nfunction $7af3f5b51489e0b5$export$253fe78d46329472(props) {\n  let {\n    selectionMode = 'none',\n    disallowEmptySelection: disallowEmptySelection,\n    allowDuplicateSelectionEvents: allowDuplicateSelectionEvents\n  } = props; // We want synchronous updates to `isFocused` and `focusedKey` after their setters are called.\n  // But we also need to trigger a react re-render. So, we have both a ref (sync) and state (async).\n\n  let isFocusedRef = $Qsto2$useRef(false);\n  let [, setFocused] = $Qsto2$useState(false);\n  let focusedKeyRef = $Qsto2$useRef(null);\n  let childFocusStrategyRef = $Qsto2$useRef(null);\n  let [, setFocusedKey] = $Qsto2$useState(null);\n  let selectedKeysProp = $Qsto2$useMemo(() => $7af3f5b51489e0b5$var$convertSelection(props.selectedKeys), [props.selectedKeys]);\n  let defaultSelectedKeys = $Qsto2$useMemo(() => $7af3f5b51489e0b5$var$convertSelection(props.defaultSelectedKeys, new $e40ea825a81a3709$export$52baac22726c72bf()), [props.defaultSelectedKeys]);\n  let [selectedKeys, setSelectedKeys] = $Qsto2$useControlledState(selectedKeysProp, defaultSelectedKeys, props.onSelectionChange);\n  let disabledKeysProp = $Qsto2$useMemo(() => props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [props.disabledKeys]);\n  let [selectionBehavior, setSelectionBehavior] = $Qsto2$useState(props.selectionBehavior || 'toggle'); // If the selectionBehavior prop is set to replace, but the current state is toggle (e.g. due to long press\n  // to enter selection mode on touch), and the selection becomes empty, reset the selection behavior.\n\n  if (props.selectionBehavior === 'replace' && selectionBehavior === 'toggle' && typeof selectedKeys === 'object' && selectedKeys.size === 0) setSelectionBehavior('replace');\n  return {\n    selectionMode: selectionMode,\n    disallowEmptySelection: disallowEmptySelection,\n    selectionBehavior: selectionBehavior,\n    setSelectionBehavior: setSelectionBehavior,\n\n    get isFocused() {\n      return isFocusedRef.current;\n    },\n\n    setFocused(f) {\n      isFocusedRef.current = f;\n      setFocused(f);\n    },\n\n    get focusedKey() {\n      return focusedKeyRef.current;\n    },\n\n    get childFocusStrategy() {\n      return childFocusStrategyRef.current;\n    },\n\n    setFocusedKey(k) {\n      let childFocusStrategy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'first';\n      focusedKeyRef.current = k;\n      childFocusStrategyRef.current = childFocusStrategy;\n      setFocusedKey(k);\n    },\n\n    selectedKeys: selectedKeys,\n\n    setSelectedKeys(keys) {\n      if (allowDuplicateSelectionEvents || !$7af3f5b51489e0b5$var$equalSets(keys, selectedKeys)) setSelectedKeys(keys);\n    },\n\n    disabledKeys: disabledKeysProp\n  };\n}\n\nfunction $7af3f5b51489e0b5$var$convertSelection(selection, defaultValue) {\n  if (!selection) return defaultValue;\n  return selection === 'all' ? 'all' : new $e40ea825a81a3709$export$52baac22726c72bf(selection);\n}\n\nvar $d496c0a20b6e58ec$exports = {};\n$parcel$export($d496c0a20b6e58ec$exports, \"SelectionManager\", () => $d496c0a20b6e58ec$export$6c8a5aaad13c9852);\n\nclass $d496c0a20b6e58ec$export$6c8a5aaad13c9852 {\n  /**\r\n  * The type of selection that is allowed in the collection.\r\n  */\n  get selectionMode() {\n    return this.state.selectionMode;\n  }\n  /**\r\n  * Whether the collection allows empty selection.\r\n  */\n\n\n  get disallowEmptySelection() {\n    return this.state.disallowEmptySelection;\n  }\n  /**\r\n  * The selection behavior for the collection.\r\n  */\n\n\n  get selectionBehavior() {\n    return this.state.selectionBehavior;\n  }\n  /**\r\n  * Sets the selection behavior for the collection.\r\n  */\n\n\n  setSelectionBehavior(selectionBehavior) {\n    this.state.setSelectionBehavior(selectionBehavior);\n  }\n  /**\r\n  * Whether the collection is currently focused.\r\n  */\n\n\n  get isFocused() {\n    return this.state.isFocused;\n  }\n  /**\r\n  * Sets whether the collection is focused.\r\n  */\n\n\n  setFocused(isFocused) {\n    this.state.setFocused(isFocused);\n  }\n  /**\r\n  * The current focused key in the collection.\r\n  */\n\n\n  get focusedKey() {\n    return this.state.focusedKey;\n  }\n  /** Whether the first or last child of the focused key should receive focus. */\n\n\n  get childFocusStrategy() {\n    return this.state.childFocusStrategy;\n  }\n  /**\r\n  * Sets the focused key.\r\n  */\n\n\n  setFocusedKey(key, childFocusStrategy) {\n    this.state.setFocusedKey(key, childFocusStrategy);\n  }\n  /**\r\n  * The currently selected keys in the collection.\r\n  */\n\n\n  get selectedKeys() {\n    return this.state.selectedKeys === 'all' ? new Set(this.getSelectAllKeys()) : this.state.selectedKeys;\n  }\n  /**\r\n  * The raw selection value for the collection.\r\n  * Either 'all' for select all, or a set of keys.\r\n  */\n\n\n  get rawSelection() {\n    return this.state.selectedKeys;\n  }\n  /**\r\n  * Returns whether a key is selected.\r\n  */\n\n\n  isSelected(key) {\n    if (this.state.selectionMode === 'none') return false;\n    key = this.getKey(key);\n    return this.state.selectedKeys === 'all' ? !this.state.disabledKeys.has(key) : this.state.selectedKeys.has(key);\n  }\n  /**\r\n  * Whether the selection is empty.\r\n  */\n\n\n  get isEmpty() {\n    return this.state.selectedKeys !== 'all' && this.state.selectedKeys.size === 0;\n  }\n  /**\r\n  * Whether all items in the collection are selected.\r\n  */\n\n\n  get isSelectAll() {\n    if (this.isEmpty) return false;\n    if (this.state.selectedKeys === 'all') return true;\n    if (this._isSelectAll != null) return this._isSelectAll;\n    let allKeys = this.getSelectAllKeys();\n    let selectedKeys = this.state.selectedKeys;\n    this._isSelectAll = allKeys.every(k => selectedKeys.has(k));\n    return this._isSelectAll;\n  }\n\n  get firstSelectedKey() {\n    let first = null;\n\n    for (let key of this.state.selectedKeys) {\n      let item = this.collection.getItem(key);\n      if (!first || (item === null || item === void 0 ? void 0 : item.index) < first.index) first = item;\n    }\n\n    return first === null || first === void 0 ? void 0 : first.key;\n  }\n\n  get lastSelectedKey() {\n    let last = null;\n\n    for (let key of this.state.selectedKeys) {\n      let item = this.collection.getItem(key);\n      if (!last || (item === null || item === void 0 ? void 0 : item.index) > last.index) last = item;\n    }\n\n    return last === null || last === void 0 ? void 0 : last.key;\n  }\n  /**\r\n  * Extends the selection to the given key.\r\n  */\n\n\n  extendSelection(toKey) {\n    if (this.selectionMode === 'none') return;\n\n    if (this.selectionMode === 'single') {\n      this.replaceSelection(toKey);\n      return;\n    }\n\n    toKey = this.getKey(toKey);\n    let selection; // Only select the one key if coming from a select all.\n\n    if (this.state.selectedKeys === 'all') selection = new $e40ea825a81a3709$export$52baac22726c72bf([toKey], toKey, toKey);else {\n      let selectedKeys = this.state.selectedKeys;\n      let anchorKey = selectedKeys.anchorKey || toKey;\n      selection = new $e40ea825a81a3709$export$52baac22726c72bf(selectedKeys, anchorKey, toKey);\n\n      for (let key of this.getKeyRange(anchorKey, selectedKeys.currentKey || toKey)) selection.delete(key);\n\n      for (let key1 of this.getKeyRange(toKey, anchorKey)) if (!this.state.disabledKeys.has(key1)) selection.add(key1);\n    }\n    this.state.setSelectedKeys(selection);\n  }\n\n  getKeyRange(from, to) {\n    let fromItem = this.collection.getItem(from);\n    let toItem = this.collection.getItem(to);\n\n    if (fromItem && toItem) {\n      if (fromItem.index <= toItem.index) return this.getKeyRangeInternal(from, to);\n      return this.getKeyRangeInternal(to, from);\n    }\n\n    return [];\n  }\n\n  getKeyRangeInternal(from, to) {\n    let keys = [];\n    let key = from;\n\n    while (key) {\n      let item = this.collection.getItem(key);\n      if (item && item.type === 'item' || item.type === 'cell' && this.allowsCellSelection) keys.push(key);\n      if (key === to) return keys;\n      key = this.collection.getKeyAfter(key);\n    }\n\n    return [];\n  }\n\n  getKey(key) {\n    let item = this.collection.getItem(key);\n    if (!item) // ¯\\_(ツ)_/¯\n      return key; // If cell selection is allowed, just return the key.\n\n    if (item.type === 'cell' && this.allowsCellSelection) return key; // Find a parent item to select\n\n    while (item.type !== 'item' && item.parentKey != null) item = this.collection.getItem(item.parentKey);\n\n    if (!item || item.type !== 'item') return null;\n    return item.key;\n  }\n  /**\r\n  * Toggles whether the given key is selected.\r\n  */\n\n\n  toggleSelection(key) {\n    if (this.selectionMode === 'none') return;\n\n    if (this.selectionMode === 'single' && !this.isSelected(key)) {\n      this.replaceSelection(key);\n      return;\n    }\n\n    key = this.getKey(key);\n    if (key == null) return;\n    let keys = new $e40ea825a81a3709$export$52baac22726c72bf(this.state.selectedKeys === 'all' ? this.getSelectAllKeys() : this.state.selectedKeys);\n    if (keys.has(key)) keys.delete(key);else {\n      keys.add(key);\n      keys.anchorKey = key;\n      keys.currentKey = key;\n    }\n    if (this.disallowEmptySelection && keys.size === 0) return;\n    this.state.setSelectedKeys(keys);\n  }\n  /**\r\n  * Replaces the selection with only the given key.\r\n  */\n\n\n  replaceSelection(key) {\n    if (this.selectionMode === 'none') return;\n    key = this.getKey(key);\n    if (key == null) return;\n    this.state.setSelectedKeys(new $e40ea825a81a3709$export$52baac22726c72bf([key], key, key));\n  }\n  /**\r\n  * Replaces the selection with the given keys.\r\n  */\n\n\n  setSelectedKeys(keys) {\n    if (this.selectionMode === 'none') return;\n    let selection = new $e40ea825a81a3709$export$52baac22726c72bf();\n\n    for (let key of keys) {\n      key = this.getKey(key);\n\n      if (key != null) {\n        selection.add(key);\n        if (this.selectionMode === 'single') break;\n      }\n    }\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  getSelectAllKeys() {\n    let keys = [];\n\n    let addKeys = key => {\n      while (key) {\n        if (!this.state.disabledKeys.has(key)) {\n          let item = this.collection.getItem(key);\n          if (item.type === 'item') keys.push(key); // Add child keys. If cell selection is allowed, then include item children too.\n\n          if (item.hasChildNodes && (this.allowsCellSelection || item.type !== 'item')) addKeys([...item.childNodes][0].key);\n        }\n\n        key = this.collection.getKeyAfter(key);\n      }\n    };\n\n    addKeys(this.collection.getFirstKey());\n    return keys;\n  }\n  /**\r\n  * Selects all items in the collection.\r\n  */\n\n\n  selectAll() {\n    if (this.selectionMode === 'multiple') this.state.setSelectedKeys('all');\n  }\n  /**\r\n  * Removes all keys from the selection.\r\n  */\n\n\n  clearSelection() {\n    if (!this.disallowEmptySelection && (this.state.selectedKeys === 'all' || this.state.selectedKeys.size > 0)) this.state.setSelectedKeys(new $e40ea825a81a3709$export$52baac22726c72bf());\n  }\n  /**\r\n  * Toggles between select all and an empty selection.\r\n  */\n\n\n  toggleSelectAll() {\n    if (this.isSelectAll) this.clearSelection();else this.selectAll();\n  }\n\n  select(key, e) {\n    if (this.selectionMode === 'none') return;\n\n    if (this.selectionMode === 'single') {\n      if (this.isSelected(key) && !this.disallowEmptySelection) this.toggleSelection(key);else this.replaceSelection(key);\n    } else if (this.selectionBehavior === 'toggle' || e && (e.pointerType === 'touch' || e.pointerType === 'virtual')) // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n      this.toggleSelection(key);else this.replaceSelection(key);\n  }\n  /**\r\n  * Returns whether the current selection is equal to the given selection.\r\n  */\n\n\n  isSelectionEqual(selection) {\n    if (selection === this.state.selectedKeys) return true; // Check if the set of keys match.\n\n    let selectedKeys = this.selectedKeys;\n    if (selection.size !== selectedKeys.size) return false;\n\n    for (let key of selection) {\n      if (!selectedKeys.has(key)) return false;\n    }\n\n    for (let key2 of selectedKeys) {\n      if (!selection.has(key2)) return false;\n    }\n\n    return true;\n  }\n\n  canSelectItem(key) {\n    if (this.state.selectionMode === 'none' || this.state.disabledKeys.has(key)) return false;\n    let item = this.collection.getItem(key);\n    if (!item || item.type === 'cell' && !this.allowsCellSelection) return false;\n    return true;\n  }\n\n  constructor(collection, state, options) {\n    this.collection = collection;\n    this.state = state;\n    var ref;\n    this.allowsCellSelection = (ref = options === null || options === void 0 ? void 0 : options.allowsCellSelection) !== null && ref !== void 0 ? ref : false;\n    this._isSelectAll = null;\n  }\n\n}\n\nvar $63d397230baf7bd4$exports = {};\nexport { $7af3f5b51489e0b5$export$253fe78d46329472 as useMultipleSelectionState, $d496c0a20b6e58ec$export$6c8a5aaad13c9852 as SelectionManager };","map":{"version":3,"mappings":"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","names":["$e40ea825a81a3709$export$52baac22726c72bf","Set","keys","anchorKey","currentKey","$7af3f5b51489e0b5$var$equalSets","setA","setB","size","item","has","$7af3f5b51489e0b5$export$253fe78d46329472","props","selectionMode","disallowEmptySelection","allowDuplicateSelectionEvents","isFocusedRef","$Qsto2$useRef","setFocused","$Qsto2$useState","focusedKeyRef","childFocusStrategyRef","setFocusedKey","selectedKeysProp","$Qsto2$useMemo","$7af3f5b51489e0b5$var$convertSelection","selectedKeys","defaultSelectedKeys","setSelectedKeys","$Qsto2$useControlledState","onSelectionChange","disabledKeysProp","disabledKeys","selectionBehavior","setSelectionBehavior","isFocused","current","f","focusedKey","childFocusStrategy","k","selection","defaultValue","$d496c0a20b6e58ec$export$6c8a5aaad13c9852","state","key","getSelectAllKeys","rawSelection","isSelected","getKey","isEmpty","isSelectAll","_isSelectAll","allKeys","every","firstSelectedKey","first","collection","getItem","index","lastSelectedKey","last","extendSelection","toKey","replaceSelection","getKeyRange","delete","key1","add","from","to","fromItem","toItem","getKeyRangeInternal","type","allowsCellSelection","push","getKeyAfter","parentKey","toggleSelection","addKeys","hasChildNodes","childNodes","getFirstKey","selectAll","clearSelection","toggleSelectAll","select","e","pointerType","isSelectionEqual","key2","canSelectItem","options","ref"],"sources":["C:\\Users\\ev3rg\\OneDrive\\Documents\\GitHub\\gt-bigdata-website\\node_modules\\@react-stately\\selection\\dist\\packages\\@react-stately\\selection\\src\\Selection.ts","C:\\Users\\ev3rg\\OneDrive\\Documents\\GitHub\\gt-bigdata-website\\node_modules\\@react-stately\\selection\\dist\\packages\\@react-stately\\selection\\src\\useMultipleSelectionState.ts","C:\\Users\\ev3rg\\OneDrive\\Documents\\GitHub\\gt-bigdata-website\\node_modules\\@react-stately\\selection\\dist\\packages\\@react-stately\\selection\\src\\SelectionManager.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from 'react';\n\n/**\n * A Selection is a special Set containing Keys, which also has an anchor\n * and current selected key for use when range selecting.\n */\nexport class Selection extends Set<Key> {\n  anchorKey: Key;\n  currentKey: Key;\n\n  constructor(keys?: Iterable<Key> | Selection, anchorKey?: Key, currentKey?: Key) {\n    super(keys);\n    if (keys instanceof Selection) {\n      this.anchorKey = anchorKey || keys.anchorKey;\n      this.currentKey = currentKey || keys.currentKey;\n    } else {\n      this.anchorKey = anchorKey;\n      this.currentKey = currentKey;\n    }\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key, useMemo, useRef, useState} from 'react';\nimport {MultipleSelection, SelectionBehavior, SelectionMode} from '@react-types/shared';\nimport {MultipleSelectionState} from './types';\nimport {Selection} from './Selection';\nimport {useControlledState} from '@react-stately/utils';\n\nfunction equalSets(setA, setB) {\n  if (setA.size !== setB.size) {\n    return false;\n  }\n\n  for (let item of setA) {\n    if (!setB.has(item)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport interface MultipleSelectionStateProps extends MultipleSelection {\n  /** How multiple selection should behave in the collection. */\n  selectionBehavior?: SelectionBehavior,\n  /** Whether onSelectionChange should fire even if the new set of keys is the same as the last. */\n  allowDuplicateSelectionEvents?: boolean\n}\n\n/**\n * Manages state for multiple selection and focus in a collection.\n */\nexport function useMultipleSelectionState(props: MultipleSelectionStateProps): MultipleSelectionState {\n  let {\n    selectionMode = 'none' as SelectionMode,\n    disallowEmptySelection,\n    allowDuplicateSelectionEvents\n  } = props;\n\n  // We want synchronous updates to `isFocused` and `focusedKey` after their setters are called.\n  // But we also need to trigger a react re-render. So, we have both a ref (sync) and state (async).\n  let isFocusedRef = useRef(false);\n  let [, setFocused] = useState(false);\n  let focusedKeyRef = useRef(null);\n  let childFocusStrategyRef = useRef(null);\n  let [, setFocusedKey] = useState(null);\n  let selectedKeysProp = useMemo(() => convertSelection(props.selectedKeys), [props.selectedKeys]);\n  let defaultSelectedKeys = useMemo(() => convertSelection(props.defaultSelectedKeys, new Selection()), [props.defaultSelectedKeys]);\n  let [selectedKeys, setSelectedKeys] = useControlledState(\n    selectedKeysProp,\n    defaultSelectedKeys,\n    props.onSelectionChange\n  );\n  let disabledKeysProp = useMemo(() =>\n    props.disabledKeys ? new Set(props.disabledKeys) : new Set<Key>()\n  , [props.disabledKeys]);\n  let [selectionBehavior, setSelectionBehavior] = useState(props.selectionBehavior || 'toggle');\n\n  // If the selectionBehavior prop is set to replace, but the current state is toggle (e.g. due to long press\n  // to enter selection mode on touch), and the selection becomes empty, reset the selection behavior.\n  if (props.selectionBehavior === 'replace' && selectionBehavior === 'toggle' && typeof selectedKeys === 'object' && selectedKeys.size === 0) {\n    setSelectionBehavior('replace');\n  }\n\n  return {\n    selectionMode,\n    disallowEmptySelection,\n    selectionBehavior,\n    setSelectionBehavior,\n    get isFocused() {\n      return isFocusedRef.current;\n    },\n    setFocused(f) {\n      isFocusedRef.current = f;\n      setFocused(f);\n    },\n    get focusedKey() {\n      return focusedKeyRef.current;\n    },\n    get childFocusStrategy() {\n      return childFocusStrategyRef.current;\n    },\n    setFocusedKey(k, childFocusStrategy = 'first') {\n      focusedKeyRef.current = k;\n      childFocusStrategyRef.current = childFocusStrategy;\n      setFocusedKey(k);\n    },\n    selectedKeys,\n    setSelectedKeys(keys) {\n      if (allowDuplicateSelectionEvents || !equalSets(keys, selectedKeys)) {\n        setSelectedKeys(keys);\n      }\n    },\n    disabledKeys: disabledKeysProp\n  };\n}\n\nfunction convertSelection(selection: 'all' | Iterable<Key>, defaultValue?: Selection): 'all' | Selection {\n  if (!selection) {\n    return defaultValue;\n  }\n\n  return selection === 'all'\n    ? 'all'\n    : new Selection(selection);\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {\n  Collection,\n  FocusStrategy,\n  Selection as ISelection,\n  LongPressEvent,\n  Node,\n  PressEvent,\n  SelectionBehavior,\n  SelectionMode\n} from '@react-types/shared';\nimport {Key} from 'react';\nimport {MultipleSelectionManager, MultipleSelectionState} from './types';\nimport {Selection} from './Selection';\n\ninterface SelectionManagerOptions {\n  allowsCellSelection?: boolean\n}\n\n/**\n * An interface for reading and updating multiple selection state.\n */\nexport class SelectionManager implements MultipleSelectionManager {\n  private collection: Collection<Node<unknown>>;\n  private state: MultipleSelectionState;\n  private allowsCellSelection: boolean;\n  private _isSelectAll: boolean;\n\n  constructor(collection: Collection<Node<unknown>>, state: MultipleSelectionState, options?: SelectionManagerOptions) {\n    this.collection = collection;\n    this.state = state;\n    this.allowsCellSelection = options?.allowsCellSelection ?? false;\n    this._isSelectAll = null;\n  }\n\n  /**\n   * The type of selection that is allowed in the collection.\n   */\n  get selectionMode(): SelectionMode {\n    return this.state.selectionMode;\n  }\n\n  /**\n   * Whether the collection allows empty selection.\n   */\n  get disallowEmptySelection(): boolean {\n    return this.state.disallowEmptySelection;\n  }\n\n  /**\n   * The selection behavior for the collection.\n   */\n  get selectionBehavior(): SelectionBehavior {\n    return this.state.selectionBehavior;\n  }\n\n  /**\n   * Sets the selection behavior for the collection.\n   */\n  setSelectionBehavior(selectionBehavior: SelectionBehavior) {\n    this.state.setSelectionBehavior(selectionBehavior);\n  }\n\n  /**\n   * Whether the collection is currently focused.\n   */\n  get isFocused(): boolean {\n    return this.state.isFocused;\n  }\n\n  /**\n   * Sets whether the collection is focused.\n   */\n  setFocused(isFocused: boolean) {\n    this.state.setFocused(isFocused);\n  }\n\n  /**\n   * The current focused key in the collection.\n   */\n  get focusedKey(): Key {\n    return this.state.focusedKey;\n  }\n\n  /** Whether the first or last child of the focused key should receive focus. */\n  get childFocusStrategy(): FocusStrategy {\n    return this.state.childFocusStrategy;\n  }\n\n  /**\n   * Sets the focused key.\n   */\n  setFocusedKey(key: Key, childFocusStrategy?: FocusStrategy) {\n    this.state.setFocusedKey(key, childFocusStrategy);\n  }\n\n  /**\n   * The currently selected keys in the collection.\n   */\n  get selectedKeys(): Set<Key> {\n    return this.state.selectedKeys === 'all'\n      ? new Set(this.getSelectAllKeys())\n      : this.state.selectedKeys;\n  }\n\n  /**\n   * The raw selection value for the collection.\n   * Either 'all' for select all, or a set of keys.\n   */\n  get rawSelection(): ISelection {\n    return this.state.selectedKeys;\n  }\n\n  /**\n   * Returns whether a key is selected.\n   */\n  isSelected(key: Key) {\n    if (this.state.selectionMode === 'none') {\n      return false;\n    }\n\n    key = this.getKey(key);\n    return this.state.selectedKeys === 'all'\n      ? !this.state.disabledKeys.has(key)\n      : this.state.selectedKeys.has(key);\n  }\n\n  /**\n   * Whether the selection is empty.\n   */\n  get isEmpty(): boolean {\n    return this.state.selectedKeys !== 'all' && this.state.selectedKeys.size === 0;\n  }\n\n  /**\n   * Whether all items in the collection are selected.\n   */\n  get isSelectAll(): boolean {\n    if (this.isEmpty) {\n      return false;\n    }\n\n    if (this.state.selectedKeys === 'all') {\n      return true;\n    }\n\n    if (this._isSelectAll != null) {\n      return this._isSelectAll;\n    }\n\n    let allKeys = this.getSelectAllKeys();\n    let selectedKeys = this.state.selectedKeys;\n    this._isSelectAll = allKeys.every(k => selectedKeys.has(k));\n    return this._isSelectAll;\n  }\n\n  get firstSelectedKey(): Key | null {\n    let first: Node<unknown> | null = null;\n    for (let key of this.state.selectedKeys) {\n      let item = this.collection.getItem(key);\n      if (!first || item?.index < first.index) {\n        first = item;\n      }\n    }\n\n    return first?.key;\n  }\n\n  get lastSelectedKey(): Key | null {\n    let last: Node<unknown> | null = null;\n    for (let key of this.state.selectedKeys) {\n      let item = this.collection.getItem(key);\n      if (!last || item?.index > last.index) {\n        last = item;\n      }\n    }\n\n    return last?.key;\n  }\n\n  /**\n   * Extends the selection to the given key.\n   */\n  extendSelection(toKey: Key) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single') {\n      this.replaceSelection(toKey);\n      return;\n    }\n\n    toKey = this.getKey(toKey);\n\n    let selection: Selection;\n\n    // Only select the one key if coming from a select all.\n    if (this.state.selectedKeys === 'all') {\n      selection = new Selection([toKey], toKey, toKey);\n    } else {\n      let selectedKeys = this.state.selectedKeys as Selection;\n      let anchorKey = selectedKeys.anchorKey || toKey;\n      selection = new Selection(selectedKeys, anchorKey, toKey);\n      for (let key of this.getKeyRange(anchorKey, selectedKeys.currentKey || toKey)) {\n        selection.delete(key);\n      }\n\n      for (let key of this.getKeyRange(toKey, anchorKey)) {\n        if (!this.state.disabledKeys.has(key)) {\n          selection.add(key);\n        }\n      }\n    }\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  private getKeyRange(from: Key, to: Key) {\n    let fromItem = this.collection.getItem(from);\n    let toItem = this.collection.getItem(to);\n    if (fromItem && toItem) {\n      if (fromItem.index <= toItem.index) {\n        return this.getKeyRangeInternal(from, to);\n      }\n\n      return this.getKeyRangeInternal(to, from);\n    }\n\n    return [];\n  }\n\n  private getKeyRangeInternal(from: Key, to: Key) {\n    let keys: Key[] = [];\n    let key = from;\n    while (key) {\n      let item = this.collection.getItem(key);\n      if (item && item.type === 'item' || (item.type === 'cell' && this.allowsCellSelection)) {\n        keys.push(key);\n      }\n\n      if (key === to) {\n        return keys;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n\n    return [];\n  }\n\n  private getKey(key: Key) {\n    let item = this.collection.getItem(key);\n    if (!item) {\n      // ¯\\_(ツ)_/¯\n      return key;\n    }\n\n    // If cell selection is allowed, just return the key.\n    if (item.type === 'cell' && this.allowsCellSelection) {\n      return key;\n    }\n\n    // Find a parent item to select\n    while (item.type !== 'item' && item.parentKey != null) {\n      item = this.collection.getItem(item.parentKey);\n    }\n\n    if (!item || item.type !== 'item') {\n      return null;\n    }\n\n    return item.key;\n  }\n\n  /**\n   * Toggles whether the given key is selected.\n   */\n  toggleSelection(key: Key) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single' && !this.isSelected(key)) {\n      this.replaceSelection(key);\n      return;\n    }\n\n    key = this.getKey(key);\n    if (key == null) {\n      return;\n    }\n\n    let keys = new Selection(this.state.selectedKeys === 'all' ? this.getSelectAllKeys() : this.state.selectedKeys);\n    if (keys.has(key)) {\n      keys.delete(key);\n      // TODO: move anchor to last selected key...\n      // Does `current` need to move here too?\n    } else {\n      keys.add(key);\n      keys.anchorKey = key;\n      keys.currentKey = key;\n    }\n\n    if (this.disallowEmptySelection && keys.size === 0) {\n      return;\n    }\n\n    this.state.setSelectedKeys(keys);\n  }\n\n  /**\n   * Replaces the selection with only the given key.\n   */\n  replaceSelection(key: Key) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    key = this.getKey(key);\n    if (key == null) {\n      return;\n    }\n\n    this.state.setSelectedKeys(new Selection([key], key, key));\n  }\n\n  /**\n   * Replaces the selection with the given keys.\n   */\n  setSelectedKeys(keys: Iterable<Key>) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    let selection = new Selection();\n    for (let key of keys) {\n      key = this.getKey(key);\n      if (key != null) {\n        selection.add(key);\n        if (this.selectionMode === 'single') {\n          break;\n        }\n      }\n    }\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  private getSelectAllKeys() {\n    let keys: Key[] = [];\n    let addKeys = (key: Key) => {\n      while (key) {\n        if (!this.state.disabledKeys.has(key)) {\n          let item = this.collection.getItem(key);\n          if (item.type === 'item') {\n            keys.push(key);\n          }\n\n          // Add child keys. If cell selection is allowed, then include item children too.\n          if (item.hasChildNodes && (this.allowsCellSelection || item.type !== 'item')) {\n            addKeys([...item.childNodes][0].key);\n          }\n        }\n\n        key = this.collection.getKeyAfter(key);\n      }\n    };\n\n    addKeys(this.collection.getFirstKey());\n    return keys;\n  }\n\n  /**\n   * Selects all items in the collection.\n   */\n  selectAll() {\n    if (this.selectionMode === 'multiple') {\n      this.state.setSelectedKeys('all');\n    }\n  }\n\n  /**\n   * Removes all keys from the selection.\n   */\n  clearSelection() {\n    if (!this.disallowEmptySelection && (this.state.selectedKeys === 'all' || this.state.selectedKeys.size > 0)) {\n      this.state.setSelectedKeys(new Selection());\n    }\n  }\n\n  /**\n   * Toggles between select all and an empty selection.\n   */\n  toggleSelectAll() {\n    if (this.isSelectAll) {\n      this.clearSelection();\n    } else {\n      this.selectAll();\n    }\n  }\n\n  select(key: Key, e?: PressEvent | LongPressEvent | PointerEvent) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single') {\n      if (this.isSelected(key) && !this.disallowEmptySelection) {\n        this.toggleSelection(key);\n      } else {\n        this.replaceSelection(key);\n      }\n    } else if (this.selectionBehavior === 'toggle' || (e && (e.pointerType === 'touch' || e.pointerType === 'virtual'))) {\n      // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n      this.toggleSelection(key);\n    } else {\n      this.replaceSelection(key);\n    }\n  }\n\n  /**\n   * Returns whether the current selection is equal to the given selection.\n   */\n  isSelectionEqual(selection: Set<Key>) {\n    if (selection === this.state.selectedKeys) {\n      return true;\n    }\n\n    // Check if the set of keys match.\n    let selectedKeys = this.selectedKeys;\n    if (selection.size !== selectedKeys.size) {\n      return false;\n    }\n\n    for (let key of selection) {\n      if (!selectedKeys.has(key)) {\n        return false;\n      }\n    }\n\n    for (let key of selectedKeys) {\n      if (!selection.has(key)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  canSelectItem(key: Key) {\n    if (this.state.selectionMode === 'none' || this.state.disabledKeys.has(key)) {\n      return false;\n    }\n\n    let item = this.collection.getItem(key);\n    if (!item || (item.type === 'cell' && !this.allowsCellSelection)) {\n      return false;\n    }\n\n    return true;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}